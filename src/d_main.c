// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*-
// -----------------------------------------------------------------------------
//         :oCCCCOCoc.
//     .cCO8OOOOOOOOO8Oo:
//   .oOO8OOOOOOOOOOOOOOOCc
//  cO8888:         .:oOOOOC.                                                TM
// :888888:   :CCCc   .oOOOOC.     ###      ###                    #########
// C888888:   .ooo:   .C########   #####  #####  ######    ######  ##########
// O888888:         .oO###    ###  #####  ##### ########  ######## ####    ###
// C888888:   :8O.   .C##########  ### #### ### ##    ##  ##    ## ####    ###
// :8@@@@8:   :888c   o###         ### #### ### ########  ######## ##########
//  :8@@@@C   C@@@@   oo########   ###  ##  ###  ######    ######  #########
//    cO@@@@@@@@@@@@@@@@@Oc0
//      :oO8@@@@@@@@@@Oo.
//         .oCOOOOOCc.                                      http://remood.org/
// -----------------------------------------------------------------------------
// Copyright (C) 1993-1996 by id Software, Inc.
// Copyright (C) 1998-2000 by DooM Legacy Team.
// Copyright (C) 2008-2012 GhostlyDeath (ghostlydeath@gmail.com)
// -----------------------------------------------------------------------------
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// -----------------------------------------------------------------------------
// DESCRIPTION: DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//              plus functions to determine game mode (shareware, registered),
//              parse command line parameters, configure game parameters (turbo),
//              and call the startup functions.

#ifdef LINUX
#include <sys/stat.h>
#include <sys/types.h>
#endif

#ifndef _WIN32
#include <unistd.h>				// for access
#else
#include <direct.h>
#endif
#include <fcntl.h>

#ifdef __OS2__
#include "I_os2.h"
#endif

#include "doomdef.h"

#include "command.h"
#include "console.h"

#include "doomstat.h"

#include "am_map.h"
#include "d_net.h"
#include "d_netcmd.h"
#include "dehacked.h"
#include "dstrings.h"

#include "f_wipe.h"
#include "f_finale.h"

#include "g_game.h"
#include "g_input.h"

#include "hu_stuff.h"

#include "i_sound.h"
#include "i_system.h"
#include "i_video.h"

#include "m_argv.h"
#include "m_menu.h"
#include "m_misc.h"

#include "p_setup.h"
#include "p_fab.h"
#include "p_info.h"

#include "r_main.h"
#include "r_local.h"

#include "s_sound.h"
#include "st_stuff.h"

#include "t_script.h"

#include "v_video.h"

#include "wi_stuff.h"
#include "w_wad.h"

#include "z_zone.h"
#include "d_main.h"
#include "m_cheat.h"
#include "p_chex.h"

#include "d_prof.h"

#if defined(__REMOOD_DEDICATED)
bool_t g_DedicatedServer = true;				// Dedicated Server
#else
bool_t g_DedicatedServer = false;				// Dedicated Server
#endif

//
//  DEMO LOOP
//
int demosequence;
int pagetic;
char* pagename = "TITLEPIC";
bool_t novideo = false;

//  PROTOS
void D_AdvanceDemo(void);

#ifdef LINUX
void VID_PrepareModeList(void);	// FIXME: very dirty; will use a proper include file
#endif

char* startupwadfiles[MAX_WADFILES];

bool_t devparm;					// started game with -devparm
bool_t nomonsters;				// checkparm of -nomonsters
bool_t infight = false;			//DarkWolf95:November 21, 2003: Monsters Infight!

bool_t singletics = false;		// timedemo

bool_t nomusic;
bool_t nosound;
bool_t digmusic;				// OGG/MP3 Music SSNTails 12-13-2002
bool_t newnet_use = false;
bool_t newnet_solo = false;

bool_t advancedemo;

char wadfile[1024];				// primary wad file
char mapdir[1024];				// directory of development maps

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
// referenced from i_system.c for I_GetKey()

event_t events[MAXEVENTS];
int eventhead = 0;
int eventtail;

bool_t dedicated;

/* FPS */
static int l_FPSFrameFPGS = 0;
static int l_FPSTimePerGS = 0;
static int l_FPSTrueFPS = 0;
static int l_FPSRanFPS = 0;

//
// D_PostEvent
// Called by the I/O functions when input is detected
//
void D_PostEvent(const event_t* ev)
{
	events[eventhead] = *ev;
	eventhead = (eventhead + 1) & (MAXEVENTS - 1);
}

// just for lock this function
#ifdef PC_DOS
void D_PostEvent_end(void)
{
};
#endif

bool_t shiftdown = false;

//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
void D_ProcessEvents(void)
{
	event_t* ev;
	
	for (; eventtail != eventhead; eventtail = (++eventtail) & (MAXEVENTS - 1))
	{
		ev = &events[eventtail];
		
		if (ev->type == ev_keydown && ev->data1 == KEY_SHIFT)
			shiftdown = true;
		else if (ev->type == ev_keyup && ev->data1 == KEY_SHIFT)
			shiftdown = false;
			
		// Menu input
		if (M_Responder(ev))
			continue;			// menu ate the event
			
		// console input
		if (CON_Responder(ev))
			continue;			// ate the event
			
		G_Responder(ev);
	}
}

//
// D_Display
//  draw current display, possibly wiping it from the previous
//

/*#ifdef _WIN32
void I_DoStartupMouse(void);    //win_sys.c
#endif*/

// wipegamestate can be set to -1 to force a wipe on the next draw
// added comment : there is a wipe eatch change of the gamestate
gamestate_t wipegamestate = GS_DEMOSCREEN;

CV_PossibleValue_t screenslink_cons_t[] =
{
	{0, "None"}
	,
	{wipe_ColorXForm + 1, "Color"}
	,
	{wipe_Melt + 1, "Melt"}
	,
	{wipe_Blinds + 1, "Blinds"}
	,
	{0, NULL}
};
consvar_t cv_screenslink = { "screenlink", "2", CV_SAVE, screenslink_cons_t };

// GhostlyDeath <July 8, 2009> -- Add FPS Counter
consvar_t cv_vid_drawfps = { "vid_drawfps", "0", CV_SAVE, CV_YesNo, NULL };

void D_Display(void)
{
	static bool_t menuactivestate = false;
	static gamestate_t oldgamestate = -1;
	static int borderdrawcount;
	tic_t nowtime;
	tic_t tics;
	tic_t wipestart;
	int i;
	int y;
	int a, b;
	int oldviewwidth;
	bool_t done;
	bool_t wipe;
	bool_t redrawsbar;
	bool_t viewactivestate = false;
	
	if (dedicated)
		return;
		
	if (nodrawers)
		return;					// for comparative timing / profiling
		
	redrawsbar = false;
	
	//added:21-01-98: check for change of screen size (video mode)
	if (setmodeneeded)
		SCR_SetMode();			// change video mode
		
	if (vid.recalc)
		//added:26-01-98: NOTE! setsizeneeded is set by SCR_Recalc()
		SCR_Recalc();
		
	// change the view size if needed
	if (setsizeneeded)
	{
		R_ExecuteSetViewSize();
		oldgamestate = -1;		// force background redraw
		borderdrawcount = 3;
		redrawsbar = true;
	}
	// GhostlyDeath <June 16, 2010> -- Only wipe if we set screen link (otherwise cleanup is never done)
	// save the current screen if about to wipe
	if (cv_screenslink.value && gamestate != wipegamestate)
	{
		wipe = true;
		wipe_StartScreen(0, 0, vid.width, vid.height);
	}
	else
		wipe = false;
		
	// draw buffered stuff to screen
	// BP: Used only by linux GGI version
	I_UpdateNoBlit();
	
	// do buffered drawing
	switch (gamestate)
	{
		case GS_LEVEL:
			if (!gametic)
				break;
			HU_Erase();
			if (automapactive && !automapoverlay)
				AM_Drawer();
			if (wipe || menuactivestate || vid.recalc)
				redrawsbar = true;
			break;
			
		case GS_INTERMISSION:
			WI_Drawer();
			break;
			
		case GS_FINALE:
			F_Drawer();
			break;
			
		case GS_DEMOSCREEN:
			D_PageDrawer(pagename);
		case GS_NULL:
			break;
	}
	
	// clean up border stuff
	// see if the border needs to be initially drawn
	if (gamestate == GS_LEVEL)
	{
		if (oldgamestate != GS_LEVEL)
		{
			viewactivestate = false;	// view was not active
			R_FillBackScreen();	// draw the pattern into the back screen
		}
		// see if the border needs to be updated to the screen
		if ((!automapactive || automapoverlay) && (scaledviewwidth != vid.width))
		{
			// the menu may draw over parts out of the view window,
			// which are refreshed only when needed
			if (menuactive || menuactivestate || !viewactivestate)
				borderdrawcount = 3;
				
			if (borderdrawcount)
			{
				R_DrawViewBorder();	// erase old menu stuff
				borderdrawcount--;
			}
		}
		// draw the view directly
		if (!automapactive || automapoverlay)
		{
			// added 16-6-98: render the second screen
			switch (cv_splitscreen.value)
			{
				case 1:
					if (playeringame[displayplayer[1]] && players[displayplayer[1]].mo)
					{
						//faB: Boris hack :P !!
						viewwindowy = vid.height / 2;
						activeylookup = ylookup;
						memcpy(ylookup, ylookup2, viewheight * sizeof(ylookup[0]));
						
						R_RenderPlayerView(&players[displayplayer[1]]);
						
						viewwindowy = 0;
						activeylookup = ylookup;
						memcpy(ylookup, ylookup1, viewheight * sizeof(ylookup[0]));
					}
					else
						V_DrawColorBoxEx(VEX_NOSCALESTART | VEX_NOSCALESCREEN, 0, 0, vid.height >> 1, vid.width, vid.height);
				case 0:
					if (players[displayplayer[0]].mo)
					{
						activeylookup = ylookup;
						R_RenderPlayerView(&players[displayplayer[0]]);
					}
					break;
				case 2:
				case 3:
				default:
					for (i = 0; i < 4; i++)
					{
						if (playeringame[displayplayer[i]] && players[displayplayer[i]].mo && i < cv_splitscreen.value + 1)
						{
							activeylookup = ylookup4[i];
							
							if (cv_splitscreen.value % 2 == 1)
								viewwindowx = vid.width / 2;
							if (cv_splitscreen.value > 1)
								viewwindowy = vid.height / 2;
								
							R_RenderPlayerView(&players[displayplayer[i]]);
							
							viewwindowx = 0;
							viewwindowy = 0;
						}
						else
							V_DrawColorBoxEx(VEX_NOSCALESTART | VEX_NOSCALESCREEN, 0,
									((i == 1 || i == 3) ? vid.width >> 1 : 0),
							        ((i == 2 || i == 3) ? vid.height >> 1 : 0),
							        (((i == 1 || i == 3) ? vid.width >> 1 : 0)) + (vid.width >> 1),
							        ( ((i == 2 || i == 3) ? vid.height >> 1 : 0)) + (vid.height >> 1)
								);
					}
					break;
			}
		}
		
		if (automapactive && automapoverlay)
			AM_Drawer();
			
		HU_Drawer();
		
		ST_Drawer(redrawsbar);
	}
	// change gamma if needed
	if (gamestate != oldgamestate && gamestate != GS_LEVEL)
		V_SetPalette(0);
		
	menuactivestate = menuactive;
	oldgamestate = wipegamestate = gamestate;
	
	// draw pause pic
	if (paused && (!menuactive || netgame) && (gamestate == GS_LEVEL || gamestate == GS_INTERMISSION))
	{
		patch_t* patch;
		
		if (automapactive)
			y = 4;
		else
			y = viewwindowy + 4;
		patch = W_CachePatchName("M_PAUSE", PU_CACHE);
		V_DrawScaledPatch(viewwindowx + (BASEVIDWIDTH - LittleSwapInt16(patch->width)) / 2, y, 0, patch);
	}
	//added:24-01-98:vid size change is now finished if it was on...
	vid.recalc = 0;
	
	//CON_Drawer();
	
	// Draw the menus
	M_MenuExDrawer();
	
	// Draw the console on the menu (if it is opened anyway)
	CONL_DrawConsole();
		
	D_SyncNetUpdate();
	NetUpdate();				// send out any new accumulation
	
	// GhostlyDeath <July 8, 2009> -- Add FPS Counter
	if (cv_vid_drawfps.value)
	{
		// GhostlyDeath <july 8, 2009> -- Draw FPS
		V_DrawCharacterA(VFONT_LARGE, 0, '0' + ((l_FPSTrueFPS / 100) % 10), 320 - 70, 0);
		V_DrawCharacterA(VFONT_LARGE, 0, '0' + ((l_FPSTrueFPS / 10) % 10), 320 - 60, 0);
		V_DrawCharacterA(VFONT_LARGE, 0, '.', 320 - 50, 0);
		V_DrawCharacterA(VFONT_LARGE, 0, '0' + (l_FPSTrueFPS % 10), 320 - 40, 0);
		V_DrawCharacterA(VFONT_LARGE, 0, 'F', 320 - 30, 0);
		V_DrawCharacterA(VFONT_LARGE, 0, 'P', 320 - 20, 0);
		V_DrawCharacterA(VFONT_LARGE, 0, 'S', 320 - 10, 0);
		
		V_DrawCharacterA(VFONT_OEM, 0, '0' + ((l_FPSFrameFPGS / 10) % 10), 320 - 48, 15);
		V_DrawCharacterA(VFONT_OEM, 0, '0' + (l_FPSFrameFPGS % 10), 320 - 40, 15);
		V_DrawCharacterA(VFONT_OEM, 0, 'F', 320 - 32, 15);
		V_DrawCharacterA(VFONT_OEM, 0, 'P', 320 - 24, 15);
		V_DrawCharacterA(VFONT_OEM, 0, 'G', 320 - 16, 15);
		V_DrawCharacterA(VFONT_OEM, 0, 'S', 320 - 8, 15);
		
		V_DrawCharacterA(VFONT_OEM, 0, '0' + ((l_FPSTimePerGS / 1000) % 10), 320 - 72, 24);
		V_DrawCharacterA(VFONT_OEM, 0, '.', 320 - 64, 24);
		V_DrawCharacterA(VFONT_OEM, 0, '0' + ((l_FPSTimePerGS / 100) % 10), 320 - 56, 24);
		V_DrawCharacterA(VFONT_OEM, 0, '0' + ((l_FPSTimePerGS / 10) % 10), 320 - 48, 24);
		V_DrawCharacterA(VFONT_OEM, 0, '0' + (l_FPSTimePerGS % 10), 320 - 40, 24);
		V_DrawCharacterA(VFONT_OEM, 0, 'S', 320 - 32, 24);
		V_DrawCharacterA(VFONT_OEM, 0, ':', 320 - 24, 24);
		V_DrawCharacterA(VFONT_OEM, 0, 'G', 320 - 16, 24);
		V_DrawCharacterA(VFONT_OEM, 0, 'S', 320 - 8, 24);
	}
	//I_BeginProfile();
	I_FinishUpdate();			// page flip or blit buffer
	//CONL_PrintF ("last frame update took %d\n", I_EndProfile());
	
	if (!wipe)
		return;
		
//
// wipe update
//
	if (!cv_screenslink.value)
		return;
		
	wipe_EndScreen(0, 0, vid.width, vid.height);
	
	wipestart = I_GetTime() - 1;
	y = wipestart + 2 * TICRATE;	// init a timeout
	do
	{
		do
		{
			nowtime = I_GetTime();
			tics = nowtime - wipestart;
		}
		while (!tics);
		wipestart = nowtime;
		done = wipe_ScreenWipe(cv_screenslink.value - 1, 0, 0, vid.width, vid.height, tics);
		I_OsPolling();
		I_UpdateNoBlit();
		M_Drawer();				// menu is drawn even on top of wipes
		I_FinishUpdate();		// page flip or blit buffer
	}
	while (!done && I_GetTime() < (unsigned)y);
	
	// GhostlyDeath <June 4, 2010> -- If a wipe never finished 100% we must end if
	if (!done)
	{
		//if (devparm)
		//  CONL_PrintFUL(SRCSTR__D_MAIN_C__WIPENEVERDONE, L"");
		
		// Force an end
		wipe_ScreenWipe(cv_screenslink.value - 1, 0, 0, vid.width, vid.height, -tics);
	}
	
	ST_Invalidate();
}

// =========================================================================
//   D_DoomLoop
// =========================================================================

tic_t rendergametic, oldentertics;
bool_t supdate;

//#define SAVECPU_EXPERIMENTAL

static bool_t l_FPSPanic = false;

/* D_SetFPSPanicMode() -- Try to get more FPS */
void D_SetFPSPanicMode(const bool_t a_Set)
{
	l_FPSPanic = a_Set;
}

void D_DoomLoop(void)
{
	tic_t oldentertics, entertic, realtics, rendertimeout = -1;
	uint32_t FPSNowTime, FPSLastTime, FPSLastTic = 0;
	int32_t MissedRenders = 0;
	
	if (demorecording)
		G_BeginRecording();
		
	// user settings
	COM_BufAddText("exec autoexec.cfg\n");
	
	// end of loading screen: CONL_PrintF() will no more call FinishUpdate()
	con_startup = false;
	
	CONL_PrintF("I_StartupKeyboard...\n");
	I_StartupKeyboard();
	
	/*#ifdef _WIN32
	   CONL_PrintF("I_StartupMouse...\n");
	   I_DoStartupMouse();
	   #endif */
	
	oldentertics = I_GetTime();
	
	// make sure to do a d_display to init mode _before_ load a level
	SCR_SetMode();				// change video mode
	SCR_Recalc();
	
	FPSLastTime = I_GetTimeMS();
	
	for (;;)
	{
		// get real tics
		entertic = I_GetTime();
		realtics = entertic - oldentertics;
		oldentertics = entertic;
		
#ifdef SAVECPU_EXPERIMENTAL
		if (realtics == 0)
		{
			usleep(10000);
			continue;
		}
#endif
		
		// GhostlyDeath <August 30, 2011> -- Mouse grabbing
		I_DoMouseGrabbing();
		
		// frame syncronous IO operations
		// UNUSED for the moment (18/12/98)
		I_StartFrame();
		
		// process tics (but maybe not if realtic==0)
		TryRunTics(realtics);
		if (singletics || gametic > rendergametic)
		{
			l_FPSRanFPS++;
			
			rendergametic = gametic;
			rendertimeout = entertic + TICRATE / 17;
			
			//added:16-01-98:consoleplayer -> displayplayer (hear sounds from viewpoint)
			if (!l_FPSPanic)
			{
				S_RepositionSounds();
				S_UpdateSounds(false);	// move positional sounds
			}
			// Update display, next frame, with current state.
			D_Display();
			supdate = false;
		}
		else if (rendertimeout < entertic)	// in case the server hang or netsplit
		{
			l_FPSRanFPS++;
			D_Display();
		}
		// Sound mixing for the buffer is snychronous.
		I_UpdateSound();
		
		// Update sound output.
		I_SubmitSound();
		
		// check for media change, loop music..
		I_UpdateCD();
		
		// GhostlyDeath <July 8, 2009> -- Add FPS Counter
		if (gametic % TICRATE == 0 && FPSLastTic != gametic)
		{
			FPSNowTime = I_GetTimeMS();
			
			l_FPSTimePerGS = FPSNowTime - FPSLastTime;
			l_FPSFrameFPGS = TICRATE - ((l_FPSRanFPS) % TICRATE);
			// GhostlyDeath <July 9, 2009> -- Floating point is more accurate but fixed may be faster
			l_FPSTrueFPS =		//((double)l_FPSFrameFPGS / ((double)l_FPSTimePerGS / 1000.0)) * 10.0;
			    FixedMul(FixedDiv(l_FPSFrameFPGS << FRACBITS, FixedDiv(l_FPSTimePerGS << FRACBITS, 1000 << FRACBITS)), 10 << FRACBITS) >> FRACBITS;
			    
			l_FPSRanFPS = 0;
			FPSLastTime = FPSNowTime;
			
			FPSLastTic = gametic;
			
			if (l_FPSTrueFPS > 999)
				l_FPSTrueFPS = 999;
			else if (l_FPSTrueFPS < 0)
				l_FPSTrueFPS = 0;	// This can happen with fixed point numbers
		}
	}
}

// =========================================================================
//   D_AdvanceDemo
// =========================================================================

//
// D_PageTicker
// Handles timing for warped projection
//
void D_PageTicker(void)
{
	if (--pagetic < 0)
		D_AdvanceDemo();
}

/* D_PageDrawer() -- Draws the title screen page */
void D_PageDrawer(const char* const a_LumpName)
{
	V_Image_t* Image;
	
	/* Check */
	if (!a_LumpName)
		return;
	
	/* Find image */
	Image = V_ImageFindA(a_LumpName);
	
	// Not found?
	if (!Image)
		return;
	
	/* Draw Image to screen */
	V_ImageUsage(Image, true);
	V_ImageDraw(0, Image, 0, 0, NULL);
	V_ImageUsage(Image, false);
}

//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
void D_AdvanceDemo(void)
{
	advancedemo = true;
}

//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
void D_DoAdvanceDemo(void)
{
	static bool_t RanPlusPlus = false;
	
	players[consoleplayer[0]].playerstate = PST_LIVE;	// not reborn
	advancedemo = false;
	gameaction = ga_nothing;
	
	if (cv_disabledemos.value)
		demosequence = (demosequence + 1) % 3;
	else
	{
		if (gamemode == retail)
			demosequence = (demosequence + 1) % 7;
		else
			demosequence = (demosequence + 1) % 6;
	}
	
	if (cv_disabledemos.value)
	{
		switch (demosequence)
		{
			case 0:
				switch (gamemode)
				{
					case commercial:
						pagename = "TITLEPIC";
						pagetic = TICRATE * 11;
						S_ChangeMusic(mus_dm2ttl, false);
						break;
					default:
						pagename = "TITLEPIC";
						pagetic = 170;
						S_ChangeMusic(mus_intro, false);
						break;
				}
				gamestate = GS_DEMOSCREEN;
				break;
			case 1:
				pagetic = 200;
				gamestate = GS_DEMOSCREEN;
				pagename = "RMCREDIT";
				break;
			case 2:
				gamestate = GS_DEMOSCREEN;
				if (gamemode == commercial)
				{
					pagetic = TICRATE * 11;
					pagename = "CREDIT";
					S_ChangeMusic(mus_dm2ttl, false);
				}
				else
				{
					pagetic = 200;
					pagename = "CREDIT";
				}
				break;
		}
	}
	else
	{
		switch (demosequence)
		{
			case 0:
				switch (gamemode)
				{
					case commercial:
						pagename = "TITLEPIC";
						pagetic = TICRATE * 11;
						S_ChangeMusic(mus_dm2ttl, false);
						break;
					default:
						pagename = "TITLEPIC";
						pagetic = 170;
						S_ChangeMusic(mus_intro, false);
						break;
				}
				gamestate = GS_DEMOSCREEN;
				break;
			case 1:
				pagetic = 9999999;
				G_DeferedPlayDemo("demo1");
				break;
			case 2:
				pagetic = 200;
				gamestate = GS_DEMOSCREEN;
				pagename = "RMCREDIT";
				break;
			case 3:
				pagetic = 9999999;
				G_DeferedPlayDemo("demo2");
				break;
			case 4:
				gamestate = GS_DEMOSCREEN;
				if (gamemode == commercial)
				{
					pagetic = TICRATE * 11;
					pagename = "CREDIT";
					S_ChangeMusic(mus_dm2ttl, false);
				}
				else
				{
					pagetic = 200;
					pagename = "CREDIT";
				}
				break;
			case 5:
				pagetic = 9999999;
				G_DeferedPlayDemo("demo3");
				break;
			case 6:			// THE DEFINITIVE DOOM Special Edition demo
				pagetic = 9999999;
				G_DeferedPlayDemo("demo4");
				break;
		}
	}
	
	// GhostlyDeath <August 27, 2011> -- Push all "++" parameter to the command buffer
	if (!RanPlusPlus)
	{
		M_PushSpecialPlusParameters();
		RanPlusPlus = true;
	}
}

// =========================================================================
//   D_DoomMain
// =========================================================================

//
// D_StartTitle
//
void D_StartTitle(void)
{
	int i;
	
	// Clear Profiles
	for (i = 0; i < MAXPLAYERS; i++)
		players[i].profile = NULL;
		
	MainDef.menuitems[1].status |= IT_DISABLED2;
	
	gameaction = ga_nothing;
	playerdeadview = false;
	for (i = 0; i < MAXSPLITSCREENPLAYERS; i++)
		displayplayer[i] = consoleplayer[i] = 0;
	statusbarplayer = 0;
	demosequence = -1;
	paused = false;
	D_AdvanceDemo();
	CON_ToggleOff();
}

//
// D_AddFile
//
void D_AddFile(char* file)
{
	int numwadfiles;
	char* newfile;
	
	for (numwadfiles = 0; startupwadfiles[numwadfiles]; numwadfiles++)
		;
		
	newfile = malloc(strlen(file) + 1);
	strcpy(newfile, file);
	
	startupwadfiles[numwadfiles] = newfile;
}

/***********************************************
*** NEW IWAD IDENTIFICATION AND LOADING CODE ***
***********************************************/

/*** STRUCTURES ***/

/* D_IWADInfoEx_t() -- Extended IWAD Info */
typedef struct D_IWADInfoEx_s
{
	/* Base Info */
	const char* NiceTitle;						// Nice IWAD Title name
	const char* ForceNames;						// Names for forcing [conf = 500]
	const char* BaseName;						// WAD Basename [conf = 5]
	const char* SimpleSum;						// Simple sum of WAD [conf = 40]
	const char* MD5Sum;							// MD5 Sum of WAD [conf = 50]
	const char* SHA1Sum;						// SHA-1 Sum of WAD [conf = 60]
	const char* Lumps;							// Identifying lumps [conf = 1]
	uint32_t Size;								// Size of WAD [conf = 15]
	uint32_t NumLumps;							// Number of lumps in WAD [conf = 15]
	
	/* Game Info */
	CoreGame_t CoreGame;						// Core Game
	bool_t CanDistrib;							// Distributable? (Not illegal to give away)
	const char* MapInfoLump;					// Map Info Lump
	uint32_t Flags;								// Flags for game
	
	int mission;								// Deprecated mission
	int mode;									// Deprecated mode
} D_IWADInfoEx_t;

/*** CONSTANTS ***/
const D_IWADInfoEx_t c_IWADInfos[] =
{
	/* In order of most wanted to least wanted */
	// Doom II: Hell on Earth
	{
		"Doom II: Hell on Earth",
		"doom2\0doomii\0doomtwo\0commercial\0hellonearth\0\0",
		"doom2.wad\0freedoom.wad\0\0",
		"6ff4def4bd24c6943540c790fbfe2642",
		"25e1459ca71d321525f84628f45ca8cd",
		"7ec7652fcfce8ddc6e801839291f0e28ef1d5ae7",
		"MAP01\0GRASS1\0MAP31\0MAP32\0\0",
		14604584,
		2919,
		
		COREGAME_DOOM,
		false,
		"MI_DOOM2",
		CIF_CANFILE | CIF_REGISTERED | CIF_EXTENDED | CIF_COMMERCIAL,
		
		doom2,
		commercial
	},
	
	// The Ultimate Doom
	{
		"The Ultimate Doom",
		"ultimatedoom\0udoom\0doomu\0retail\0thyfleshconsumed\0tfc\0\0",
		"doom.wad\0doomu.wad\0ultfdoom.wad\0\0",
		"befb2905b2b5df3e43a36e84e920f71f",
		"c4fe9fd920207691a9f493668e0a2083",
		"9b07b02ab3c275a6a7570c3f73cc20d63a0e3833",
		"E1M1\0E2M1\0E3M1\0E4M1\0\0",
		12408292,
		2306,
		
		COREGAME_DOOM,
		false,
		"MI_DOOM1",
		CIF_CANFILE | CIF_REGISTERED | CIF_EXTENDED,
		
		doom,
		retail
	},
	
	// Doom Shareware
	{
		"Doom Shareware",
		"sharewaredoom\0doomshareware\0shareware\0doom1\0kneedeepinthedead\0kditd\0\0",
		"doom1.wad\0\0",
		"b9e51b0a0174fb0f52f0f641a06164d7",
		"f0cefca49926d00903cf57551d901abe",
		"5b2e249b9c5133ec987b3ea77596381dc0d6bc1d",
		"E1M1\0!E2M1\0!E3M1\0!E4M1\0\0",
		4196020,
		1264,
		
		COREGAME_DOOM,
		true,
		"MI_DOOM1",
		CIF_SHAREWARE,
		
		doom,
		shareware
	},

	/* Last */
	{NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, COREGAME_DOOM, false, NULL, 0, 0}
};

/*** LOCALS ***/

CoreGame_t g_CoreGame = COREGAME_UNKNOWN;		// Core game mode
const void* g_ReMooDPtr = NULL;					// Pointer to remood.wad
const char* g_IWADMapInfoName = NULL;			// Name of IWAD MAPINFO
uint32_t g_IWADFlags = 0;						// IWAD Flags

/*** FUNCTIONS ***/

/* DS_FieldNumber() -- Get field number from string */
static const char* DS_FieldNumber(const char* const a_Str, const size_t a_Num)
{
	const char* f;
	size_t n;
	
	/* Check */
	if (!a_Str)
		return NULL;
	
	/* Seek around */
	f = a_Str;
	n = 0;
	while (*f)
	{
		// Match?
		if (n == a_Num)
			return f;
		
		// Move up
		n++;
		f += strlen(f);
	}
	
	/* Not found */
	return NULL;
}

/* DS_DetectReMooDWAD() -- Detects for ReMooD.WAD */
static bool_t DS_DetectReMooDWAD(const bool_t a_Pushed, const struct WL_WADFile_s* const a_WAD)
{
	const WL_WADFile_t* Rover;
	
	/* Clear always */
	g_ReMooDPtr = NULL;
	
	/* Detect */
	Rover = NULL;
	while ((Rover = WL_IterateVWAD(Rover, true)))
	{
		/* Check if it contains VERSION and REMOOD */
		if (WL_FindEntry(Rover, 0, "REMOOD") && WL_FindEntry(Rover, 0, "VERSION"))
		{
			// Set to this WAD and return
			g_ReMooDPtr = Rover;
			return true;
		}
	}
	
	/* Success */
	return true;
}

/* DS_DetectGameMode() -- Detects game mode based on pushed WADs */
static bool_t DS_DetectGameMode(const bool_t a_Pushed, const struct WL_WADFile_s* const a_WAD)
{
	int32_t* Confidence;
	int32_t TotalScore;
	size_t NumConf, i, j, Best;
	const WL_WADFile_t* BaseWAD;
	const char* Field;
	const char* ForceName;
	bool_t Match;
	
	/* Get the first WAD */
	BaseWAD = WL_IterateVWAD(NULL, true);
	
	// No WAD? -- Must have all been popped off then
	if (!BaseWAD)
	{
		if (devparm)
			CONL_PrintF("DS_DetectGameMode: Stack empty, there is no game.\n");
		g_CoreGame = COREGAME_UNKNOWN;
		return true;
	}
	
	// Is the stack already placed?
	if (g_CoreGame != COREGAME_UNKNOWN)
	{
		if (devparm)
			CONL_PrintF("DS_DetectGameMode: Already detected, no need to detect.\n");
		return true;
	}
	
	/* Debug */
	if (devparm)
		CONL_PrintF("DS_DetectGameMode: Detecting game type...\n");
	
	/* Allocate Confidence */
	NumConf = (sizeof(c_IWADInfos) / sizeof(D_IWADInfoEx_t)) - 1;
	Confidence = Z_Malloc(sizeof(*Confidence) * NumConf, PU_STATIC, NULL);
	
	/* Get forced name */
	if (M_CheckParm("-game"))
		ForceName = M_GetNextParm();
	else
		ForceName = NULL;
	
	/* Determine confidence levels */
	for (TotalScore = 0, i = 0; i < NumConf; i++)
	{
		// Conf = 500 :: Forced name
		if (ForceName)
			for (j = 0;; j++)
			{
				// Get field
				Field = DS_FieldNumber(c_IWADInfos[i].ForceNames, j);
			
				// No more?
				if (!Field)
					break;
			
				// Check based on field
				else
					if (strcasecmp(Field, ForceName) == 0)
					{
						Confidence[i] += 500;
						TotalScore += 500;
					}
			}
		
		// Conf = 5 :: Basename vs DOSName
		for (j = 0;; j++)
		{
			// Get field
			Field = DS_FieldNumber(c_IWADInfos[i].BaseName, j);
			
			// No more?
			if (!Field)
				break;
			
			// Check based on field
			else
				if (strcasecmp(Field, BaseWAD->__Private.__DOSName) == 0)
				{
					Confidence[i] += 5;
					TotalScore += 5;
				}
		}
		
		// Conf = 40 :: Simple sum matches
		if (strcasecmp(c_IWADInfos[i].SimpleSum, BaseWAD->SimpleSumChars) == 0)
		{
			Confidence[i] += 40;
			TotalScore += 40;
		}
		
		// Conf = 15 :: Size
		if (BaseWAD->__Private.__Size == c_IWADInfos[i].Size)
		{
			Confidence[i] += 15;
			TotalScore += 15;
		}
		
		// Conf = 15 :: NumLumps
		if (BaseWAD->NumEntries == c_IWADInfos[i].NumLumps)
		{
			Confidence[i] += 15;
			TotalScore += 15;
		}
		
		// Conf = 1 :: Lumps in WAD
		for (j = 0;; j++)
		{
			// Get field
			Field = DS_FieldNumber(c_IWADInfos[i].Lumps, j);
			
			// No more?
			if (!Field)
				break;
			
			// Check based on field
			else
			{
				// If Field starts with !, it is NOT in the WAD
				Match = true;
				if (Field[0] == '!')
				{
					Match = false;
					Field++;	// Remove !
				}
				
				// Find in WAD
				if ((WL_FindEntry(BaseWAD, 0, Field) != NULL) == Match)
				{
					Confidence[i] += 1;
					TotalScore += 1;
				}
			}
		}
	}
	
	/* Find the best match */
	// Look for the best
	for (i = 0, Best = 0; i < NumConf; i++)
	{
		// A nice message
		if (devparm)
			CONL_PrintF("DS_DetectGameMode: %3i/%-3i: %s\n", Confidence[i], TotalScore, c_IWADInfos[i].NiceTitle);
		
		// Is this the best?
		if (Confidence[i] > Confidence[Best])
			Best = i;
	}
	
	// Set the best
	if (devparm)
		CONL_PrintF("DS_DetectGameMode: Selecting %s.\n", c_IWADInfos[Best].NiceTitle);
	
	g_CoreGame = c_IWADInfos[Best].CoreGame;
	gamemode = c_IWADInfos[Best].mode;
	gamemission = c_IWADInfos[Best].mission;
	
	g_IWADMapInfoName = c_IWADInfos[Best].MapInfoLump;
	g_IWADFlags = c_IWADInfos[Best].Flags;
	
	/* Cleanup */
	Z_Free(Confidence);
	
	return true;
}

/* D_LoadGameFiles() -- Finds the game data */
void D_LoadGameFilesEx(void)
{
	char DiscoveredPath[PATH_MAX];
	const char* CheckWAD;
	uint8_t OK;
	size_t i, j;
	const char* Field;
	
	/* Register game identifier, based on pushes */
	if (devparm)
		CONL_PrintF("D_LoadGameFilesEx: Registering mode detector.\n");
	if (!WL_RegisterOCCB(DS_DetectGameMode, 1))
		I_Error("D_LoadGameFilesEx: Failed to register IWAD OCCB!");
	if (!WL_RegisterOCCB(DS_DetectReMooDWAD, 2))
		I_Error("D_LoadGameFilesEx: Failed to register ReMooD OCCB!");
	
	/* Clear */
	OK = 0;
	memset(DiscoveredPath, 0, sizeof(DiscoveredPath));
	
	/* Discover an IWAD */
	// Via -iwad
	if (M_CheckParm("-iwad"))
	{
		// Get the WAD
		CheckWAD = M_GetNextParm();
		
		// OK?
		if (CheckWAD)
			if (WL_LocateWAD(CheckWAD, NULL, DiscoveredPath, PATH_MAX))
				OK |= 1;
			else
			{
				// Try the base name of the IWAD
				CheckWAD = WL_BaseNameEx(CheckWAD);
				
				if (WL_LocateWAD(CheckWAD, NULL, DiscoveredPath, PATH_MAX))
					OK |= 1;
			}
		
		// Debug
		if (devparm)
			if (OK)
				CONL_PrintF("D_LoadGameFilesEx: Pass via -iwad not found\n");
	}
	
	// Not found, do standard rotary search
	if (!OK)
		// For every WAD in the chain
		for (i = 0; c_IWADInfos[i].BaseName; i++)
		{
			for (j = 0;; j++)
			{
				// Get field
				Field = DS_FieldNumber(c_IWADInfos[i].BaseName, j);
				
				fprintf(stderr, "%i == %s\n", (int)j, Field);
				
				// No more fields
				if (!Field)
					break;
				
				// Field was found
				else
				{
					// Devparm here
					if (devparm)
						CONL_PrintF("D_LoadGameFilesEx: Discovering \"%s\"...\n", Field);
					
					// Do the actual check
					if (WL_LocateWAD(Field, NULL, DiscoveredPath, PATH_MAX))
					{
						OK |= 1;
						break;
					}
				}
			}
			
			// Found something
			if (OK)
				break;
		}
	
	// Still not found?
	if (!OK)
	{
		I_Error("D_LoadGameFilesEx: Could not find an IWAD. Please use -iwad to directly locate it, or pass -waddir a path to its location.");
		return;
	}
	
	/* Prepare IWAD for loading */
	// Debug
	if (devparm)
		CONL_PrintF("D_LoadGameFilesEx: Found IWAD \"%s\".\n", DiscoveredPath);
	
	// Add it to the files to load
	D_AddFile(DiscoveredPath);
	
	/* Discover ReMooD.wad */
	// Clear OK
	OK = 0;
	
	// Via -remoodwad
	if (M_CheckParm("-remoodwad"))
	{
		// Get the WAD
		CheckWAD = M_GetNextParm();
		
		// OK?
		if (CheckWAD)
			if (WL_LocateWAD(CheckWAD, NULL, DiscoveredPath, PATH_MAX))
				OK |= 1;
			else
			{
				// Try the base name of the IWAD
				CheckWAD = WL_BaseNameEx(CheckWAD);
				
				if (WL_LocateWAD(CheckWAD, NULL, DiscoveredPath, PATH_MAX))
					OK |= 1;
			}
		
		// Debug
		if (devparm)
			if (OK)
				CONL_PrintF("D_LoadGameFilesEx: Pass via -remoodwad not found\n");
	}
	
	// Not found, do standard search
	if (!OK)
		if (WL_LocateWAD("remood.wad", NULL, DiscoveredPath, PATH_MAX))
			OK |= 1;
	
	// Still not found?
	if (!OK)
	{
		I_Error("D_LoadGameFilesEx: Could not find a ReMooD.wad. Please use -remoodwad to directly locate it, or pass -waddir a path to its location.");
		return;
	}
	
	/* Prepare ReMooD.wad for loading */
	// Debug
	if (devparm)
		CONL_PrintF("D_LoadGameFilesEx: Found ReMooD.wad \"%s\".\n", DiscoveredPath);
	
	// Add it to the files to load
	D_AddFile(DiscoveredPath);
}

/***********************************************
************************************************
***********************************************/

#ifdef _WIN32
#define PATHDELIM '\\'
#else
#define PATHDELIM '/'
#endif

/* D_AddPWADs() -- Add PWADs from -file */
// GhostlyDeath <October 24, 2010> -- Greatly improved
void D_AddPWADs(void)
{
	char* PWADArg = NULL;
	char WADPath[256];
	
	/* Load every -file */
	if (M_CheckParm("-file"))
		while (M_IsNextParm())
		{
			// Get it
			PWADArg = M_GetNextParm();
			
			// Find it
			if (PWADArg)
				if (W_FindWad(PWADArg, NULL, WADPath, 256))
				{
					// Add it
					D_AddFile(WADPath);
					
					// Modify Game
					modifiedgame = true;
				}
		}
}

//added:11-01-98:
//
//  Center the title string, then add the date and time of compilation.
//
void D_MakeTitleString(char* s)
{
	char temp[82];
	char* t;
	char* u;
	int i;
	
	for (i = 0, t = temp; i < 82; i++)
		*t++ = ' ';
		
	for (t = temp + (80 - strlen(s)) / 2, u = s; *u != '\0';)
		*t++ = *u++;
		
	u = __DATE__;
	for (t = temp + 1, i = 11; i--;)
		*t++ = *u++;
	u = __TIME__;
	for (t = temp + 71, i = 8; i--;)
		*t++ = *u++;
		
	temp[80] = '\0';
	strcpy(s, temp);
}

extern bool_t g_PaintBallMode;

//
// D_DoomMain
//
void D_DoomMain(void)
{
	int i;
	int p;
	char file[256];
	char legacy[82];			//added:18-02-98: legacy title banner
	char title[82];				//added:11-01-98:moved, doesn't need to be global
	
	int startepisode;
	int startmap;
	bool_t autostart;
	
	// GhostlyDeath <November 18, 2008> -- Move devparm up here
	devparm = M_CheckParm("-devparm");
	g_QuietConsole = M_CheckParm("-quiet");
	g_PaintBallMode = M_CheckParm("-paintballmode");
	
	// GhostlyDeath <January 15, 2012> -- Check for dedicated server
#if !defined(__REMOOD_DEDICATED)
	g_DedicatedServer = M_CheckParm("-dedicated");
#else
	g_DedicatedServer = true;
#endif

	// Replace old variable
	dedicated = g_DedicatedServer;
	
	// GhostlyDeath <July 6, 2008> -- initialize fields
	memset(player_names, 0, sizeof(player_names));
	memset(team_names, 0, sizeof(team_names));
	for (i = 0; i < MAXPLAYERS; i++)
	{
		sprintf(player_names[i], "Player %i", i + 1);
		sprintf(team_names[i], "Team %i", i + 1);
	}
	
	if (M_CheckParm("-novideo"))
		novideo = true;
		
	//added:18-02-98:keep error messages until the final flush(stderr)
	//if (setvbuf(stderr, NULL, _IOFBF, 1000))
	//  CONL_PrintF("setvbuf didnt work\n");
	
	// get parameters from a response file (eg: doom3 @parms.txt)
	M_FindResponseFile();
	
	/*** New Initialization ***/
	/* Core */
	Z_Init();
	CONL_Init(4096, 1024);
	
	/* Initialize widgets */
	if (!g_DedicatedServer)
		if (!V_InitWidgetSystem())
			I_Error("D_Main: Failed to initialize the widget handler.");
	
	/* Adapters */
	V_ImageFindA(NULL);					// Bump image loaders
	D_InitRMOD();						// Initialize RMOD
	V_MapGraphicalCharacters();			// Unicode chars
	P_PrepareLevelInfoEx();				// Level information
	R_LoadTextures();					// Load texture info
	P_ExtraSpecialStuff();				// Initialize extra special stuff
	P_EXGSRegisterStuff();				// Extended Game Settings stuff
	/**************************/
	
	// GhostlyDeath <December 14, 2011> -- Use extended identify version
	D_LoadGameFilesEx();
	
	// identify the main IWAD file to use
	//IdentifyVersion();
	
	//setbuf(stdout, NULL);     // non-buffered output
	modifiedgame = false;
	
	nomonsters = M_CheckParm("-nomonsters");
	
	//added:11-01-98:center the string, add compilation time and date.
	sprintf(legacy, "ReMooD v%i.%i%c \"%s\"", REMOOD_MAJORVERSION, REMOOD_MINORVERSION, REMOOD_RELEASEVERSION, REMOOD_VERSIONCODESTRING);
	D_MakeTitleString(legacy);
	
	CONL_PrintF("%s\n", legacy);
	
	if (devparm)
		CONL_PrintF(D_DEVSTR);
		
	// default savegame
	strcpy(savegamename, text[NORM_SAVEI_NUM]);
	
	// add any files specified on the command line with -file wadfile
	// to the wad list
	//
	// convenience hack to allow -wart e m to add a wad file
	// prepend a tilde to the filename so wadfile will be reloadable
	p = M_CheckParm("-wart");
	if (p)
	{
		myargv[p][4] = 'p';		// big hack, change to -warp
		
		// Map name handling.
		switch (gamemode)
		{
			case shareware:
			case retail:
			case registered:
				sprintf(file, "~" DEVMAPS "E%cM%c.wad", myargv[p + 1][0], myargv[p + 2][0]);
				CONL_PrintF("Warping to Episode %s, Map %s.\n", myargv[p + 1], myargv[p + 2]);
				break;
				
			case commercial:
			default:
				p = atoi(myargv[p + 1]);
				if (p < 10)
					sprintf(file, "~" DEVMAPS "cdata/map0%i.wad", p);
				else
					sprintf(file, "~" DEVMAPS "cdata/map%i.wad", p);
				break;
		}
		D_AddFile(file);
	}
	
	if (M_CheckParm("-file"))
	{
		// the parms after p are wadfile/lump names,
		// until end of parms or another - preceded parm
		D_AddPWADs();
	}
	// load dehacked file
	p = M_CheckParm("-dehacked");
	if (!p)
		p = M_CheckParm("-deh");	//Fab:02-08-98:like Boom & DosDoom
	if (p != 0)
	{
		while (M_IsNextParm())
			D_AddFile(M_GetNextParm());
	}
	// get skill / episode / map from parms
	gameskill = sk_medium;
	startepisode = 1;
	startmap = 1;
	autostart = false;
	
	p = M_CheckParm("-skill");
	if (p && p < myargc - 1)
	{
		gameskill = myargv[p + 1][0] - '1';
		autostart = true;
	}
	
	p = M_CheckParm("-episode");
	if (p && p < myargc - 1)
	{
		startepisode = myargv[p + 1][0] - '0';
		startmap = 1;
		autostart = true;
	}
	
	p = M_CheckParm("-warp");
	if (p && p < myargc - 1)
	{
		if (gamemode == commercial)
			startmap = atoi(myargv[p + 1]);
		else
		{
			startepisode = myargv[p + 1][0] - '0';
			if (p < myargc - 2 && myargv[p + 2][0] >= '0' && myargv[p + 2][0] <= '9')
				startmap = myargv[p + 2][0] - '0';
			else
				startmap = 1;
		}
		autostart = true;
	}
	
	CONL_PrintF(text[Z_INIT_NUM]);
	
	G_InitKeys();
	
	// adapt tables to legacy needs
	P_PatchInfoTables();
	
	if (gamemode == chexquest1)
		Chex1PatchEngine();
		
	CONL_PrintF(text[W_INIT_NUM]);
	// load wad, including the main wad file
	if (W_InitMultipleFiles(startupwadfiles) == 0)
		I_Error("A WAD file was not found\n");
		
	// GhostlyDeath <October 24, 2010> -- Load WAD Data
	W_LoadData();
	
	//Hurdler: someone wants to keep those lines?
	//BP: i agree with you why should be registered to play someone wads ?
	//    unfotunately most addistional wad have more texture and monsters
	//    that sharware wad do, so there will miss resourse :(
	
	//added:28-02-98: check for Ultimate doom.
	//if ( (gamemode==registered) && (W_CheckNumForName("E4M1") > 0) )
	//    gamemode = retail;
	
	// Check for -file in shareware
	if (modifiedgame)
	{
		// These are the lumps that will be checked in IWAD,
		// if any one is not present, execution will be aborted.
		char name[23][8] =
		{
			"e2m1", "e2m2", "e2m3", "e2m4", "e2m5", "e2m6", "e2m7", "e2m8",
			"e2m9",
			"e3m1", "e3m3", "e3m3", "e3m4", "e3m5", "e3m6", "e3m7", "e3m8",
			"e3m9",
			"dphoof", "bfgga0", "heada1", "cybra1", "spida1d1"
		};
		int i;
		
		if (gamemode == shareware)
			CONL_PrintF("\nYou shouldn't use -file with the shareware version. Register!");
			
		// Check for fake IWAD with right name,
		// but w/o all the lumps of the registered version.
		if (gamemode == registered)
			for (i = 0; i < 23; i++)
				if (W_CheckNumForName(name[i]) == INVALIDLUMP)
					CONL_PrintF("\nThis is not the registered version.");
	}
	// If additonal PWAD files are used, print modified banner
	if (modifiedgame)
		CONL_PrintF(text[MODIFIED_NUM]);
		
	// Check and print which version is executed.
	switch (gamemode)
	{
		case shareware:
		case indetermined:
			CONL_PrintF(text[SHAREWARE_NUM]);
			break;
		case registered:
		case retail:
		case commercial:
			CONL_PrintF(text[COMERCIAL_NUM]);
			break;
		default:
			// Ouch.
			break;
	}
	cht_Init();
	
	//---------------------------------------------------- READY SCREEN
	//printf("\nI_StartupComm...");
	
	CONL_PrintF("I_StartupTimer...\n");
	I_StartupTimer();
	
	CONL_PrintF("I_InitNetwork...\n");
	I_InitNetwork();
	
	// now initted automatically by use_mouse var code
	//CONL_PrintF("I_StartupMouse...\n");
	//I_StartupMouse ();
	
	//CONL_PrintF ("I_StartupKeyboard...\n");
	//I_StartupKeyboard (); // FIXME: this is a dummy, we can remove it!
	
	// now initialised automatically by use_joystick var code
	//CONL_PrintF (text[I_INIT_NUM]);
	//I_InitJoystick ();
	
	CONL_PrintF("I_StartupGraphics...\n");
	I_StartupGraphics();
	
	//--------------------------------------------------------- CONSOLE
	// setup loading screen
	SCR_Startup();
	SCR_ReclassBuffers();
	
	// we need the font of the console
	CONL_PrintF(text[HU_INIT_NUM]);
	HU_Init();
	
	COM_Init();
	CON_Init();
	
	D_RegisterClientCommands();	//Hurdler: be sure that this is called before D_CheckNetGame
	D_AddDeathmatchCommands();
	ST_AddCommands();
	T_AddCommands();
	P_Info_AddCommands();
	R_RegisterEngineStuff();
	S_RegisterSoundStuff();
	PROF_Init();
	CV_RegisterVar(&cv_screenslink);
	
	CONL_PrintF(text[M_INIT_NUM]);
	M_Init();
	
	//Fab:29-04-98: do some dirty chatmacros strings initialisation
	HU_HackChatmacros();
	//--------------------------------------------------------- CONFIG.CFG
	M_FirstLoadConfig();		// WARNING : this do a "COM_BufExecute()"
	
	VID_PrepareModeList();		// Regenerate Modelist according to cv_fullscreen
	
	// set user default mode or mode set at cmdline
	SCR_CheckDefaultMode();
	
	wipegamestate = gamestate;
	//------------------------------------------------ COMMAND LINE PARAMS
	
	// Initialize CD-Audio
	if (!M_CheckParm("-nocd"))
		I_InitCD();
	if (M_CheckParm("-respawn"))
		COM_BufAddText("respawnmonsters 1\n");
	if (M_CheckParm("-teamplay"))
		COM_BufAddText("teamplay 1\n");
	if (M_CheckParm("-teamskin"))
		COM_BufAddText("teamplay 2\n");
	if (M_CheckParm("-splitscreen"))
		CV_SetValue(&cv_splitscreen, 1);
	if (M_CheckParm("-altdeath"))
		COM_BufAddText("deathmatch 2\n");
	else if (M_CheckParm("-deathmatch"))
		COM_BufAddText("deathmatch 1\n");
	if (M_CheckParm("-fast"))
		COM_BufAddText("fastmonsters 1\n");
	if (M_CheckParm("-predicting"))
		COM_BufAddText("predictingmonsters 1\n");	//added by AC
		
	if (M_CheckParm("-timer"))
	{
		char* s = M_GetNextParm();
		
		COM_BufAddText(va("timelimit %s\n", s));
	}
	
	if (M_CheckParm("-avg"))
	{
		COM_BufAddText("timelimit 20\n");
		CONL_PrintF(text[AUSTIN_NUM]);
	}
	// turbo option, is not meant to be saved in config, still
	// supported at cmd-line for compatibility
	if (M_CheckParm("-turbo") && M_IsNextParm())
		COM_BufAddText(va("turbo %s\n", M_GetNextParm()));
		
	// push all "+" parameter at the command buffer
	M_PushSpecialParameters();
	
	CONL_PrintF(text[R_INIT_NUM]);
	R_Init();
	
	//
	// setting up sound
	//
	CONL_PrintF(text[S_SETSOUND_NUM]);
	nosound = M_CheckParm("-nosound");
	nomusic = M_CheckParm("-nomusic");	// WARNING: DOS version initmusic in I_StartupSound
	digmusic = M_CheckParm("-digmusic");	// SSNTails 12-13-2002
	S_Init(cv_soundvolume.value, cv_musicvolume.value);
	
	CONL_PrintF(text[ST_INIT_NUM]);
	ST_Init();
	
	////////////////////////////////
	// SoM: Init FraggleScript
	////////////////////////////////
	T_Init();
	
	// init all NETWORK
	CONL_PrintF(text[D_CHECKNET_NUM]);
	if (D_CheckNetGame())
		autostart = true;
		
	// check for a driver that wants intermission stats
	p = M_CheckParm("-statcopy");
	if (p && p < myargc - 1)
	{
		I_Error("Sorry but statcopy isn't supported at this time\n");
		/*
		   // for statistics driver
		   extern  void*   statcopy;
		
		   statcopy = (void*)atoi(myargv[p+1]);
		   CONL_PrintF (text[STATREG_NUM]);
		 */
	}
	// start the apropriate game based on parms
	p = M_CheckParm("-record");
	if (p && p < myargc - 1)
	{
		G_RecordDemo(myargv[p + 1]);
		autostart = true;
	}
	// demo doesn't need anymore to be added with D_AddFile()
	p = M_CheckParm("-playdemo");
	if (!p)
		p = M_CheckParm("-timedemo");
	if (p && M_IsNextParm())
	{
		char tmp[MAX_WADPATH];
		
		// add .lmp to identify the EXTERNAL demo file
		
		strcpy(tmp, M_GetNextParm());
		// get spaced filename or directory
		while (M_IsNextParm())
		{
			strcat(tmp, " ");
			strcat(tmp, M_GetNextParm());
		}
		
		// GhostlyDeath <July 6, 20008> -- Enable playback of internal demos again
		if (W_CheckNumForName(tmp) == INVALIDLUMP)
			FIL_DefaultExtension(tmp, ".lmp");
			
		CONL_PrintF("Playing demo %s.\n", tmp);
		
		if ((p = M_CheckParm("-playdemo")))
		{
			singledemo = true;	// quit after one demo
			G_DeferedPlayDemo(tmp);
		}
		else
			G_TimeDemo(tmp);
		gamestate = wipegamestate = GS_NULL;
		
		return;
	}
	
	p = M_CheckParm("-loadgame");
	if (p && p < myargc - 1)
	{
		G_LoadGame(atoi(myargv[p + 1]));
	}
	else
	{
		if (autostart || netgame || M_CheckParm("+connect") || M_CheckParm("-connect"))
		{
			//added:27-02-98: reset the current version number
			G_Downgrade(VERSION);
			gameaction = ga_nothing;
			COM_BufAddText(va("map \"%s\"\n", G_BuildMapName(startepisode, startmap)));
		}
		else
			D_StartTitle();		// start up intro loop
			
	}
}

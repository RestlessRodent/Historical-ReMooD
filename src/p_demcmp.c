// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*-
// ----------------------------------------------------------------------------
//         :oCCCCOCoc.
//     .cCO8OOOOOOOOO8Oo:
//   .oOO8OOOOOOOOOOOOOOOCc
//  cO8888:         .:oOOOOC.                                                TM
// :888888:   :CCCc   .oOOOOC.     ###      ###                    #########
// C888888:   .ooo:   .C########   #####  #####  ######    ######  ##########
// O888888:         .oO###    ###  #####  ##### ########  ######## ####    ###
// C888888:   :8O.   .C##########  ### #### ### ##    ##  ##    ## ####    ###
// :8@@@@8:   :888c   o###         ### #### ### ########  ######## ##########
//  :8@@@@C   C@@@@   oo########   ###  ##  ###  ######    ######  #########
//    cO@@@@@@@@@@@@@@@@@Oc0
//      :oO8@@@@@@@@@@Oo.
//         .oCOOOOOCc.                                      http://remood.org/
// ----------------------------------------------------------------------------
// Copyright (C) 2008-2013 GhostlyDeath <ghostlydeath@remood.org>
//                                      <ghostlydeath@gmail.com>
// ----------------------------------------------------------------------------
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// ----------------------------------------------------------------------------
// DESCRIPTION:
//      Demo Compatibility

#include "doomdef.h"
#include "p_demcmp.h"
#include "m_menu.h"
#include "g_input.h"
#include "p_local.h"
#include "g_game.h"
#include "p_inter.h"
#include "m_argv.h"
#include "t_ini.h"

/*****************************
*** EXTENDED GAME SETTINGS ***
*****************************/

/*** STRUCTURES ***/

/* P_XGSNiceVersion_t -- Nice version information */
typedef struct P_XGSNiceVersion_s
{
	uint16_t VersionID;							// Version ID
	const char* const NiceName;					// Nice name for version
} P_XGSNiceVersion_t;

/*** LOCALS ***/

// c_PEXGSPVInteger -- Signed Integer
const CONL_VarPossibleValue_t c_PEXGSPVInteger[] =
{
	// End
	{-32767, "MINVAL"},
	{32767, "MAXVAL"},
	{0, NULL},
};

// c_PEXGSPVPositive -- Positive Integer
const CONL_VarPossibleValue_t c_PEXGSPVPositive[] =
{
	// End
	{0, "MINVAL"},
	{32767, "MAXVAL"},
	{0, NULL},
};

// c_PEXGSPVFixed -- Signed Fixed Value
const CONL_VarPossibleValue_t c_PEXGSPVFixed[] =
{
	// End
	{-32767 << FRACBITS, "MINVAL"},
	{32767 << FRACBITS, "MAXVAL"},
	{0, NULL},
};

// c_PEXGSPVBoolean -- Boolean
const CONL_VarPossibleValue_t c_PEXGSPVBoolean[] =
{
	// False
	{0, "no"},
	{0, "off"},
	{0, "false"},
	
	// True
	{1, "yes"},
	{1, "on"},
	{1, "true"},
	
	// End
	{0, "MINVAL"},
	{1, "MAXVAL"},
	{0, NULL},
};

// c_PEXGSPVTeamPlay -- Team Play Value
const CONL_VarPossibleValue_t c_PEXGSPVTeamPlay[] =
{
	{0, "Off"},
	{1, "Color"},
	{2, "Skin"},	
	
	// End
	{0, "MINVAL"},
	{2, "MAXVAL"},
	{0, NULL},
};

// c_PEXGSPVSkill -- Current Skill Level
const CONL_VarPossibleValue_t c_PEXGSPVSkill[] =
{
	// I'm Too Young To Die
	{0, "I\'m Too Young To Die"},
	{0, "Thou Needeth A Wet-Nurse"},
	{0, "baby"},
	{0, "itytd"},
	{0, "tnawn"},
	
	// Hey, Not Too Rough
	{1, "Hey, Not Too Rough"},
	{1, "Yellowbellies-R-Us"},
	{1, "easy"},
	{1, "hntr"},
	{1, "ntr"},
	{1, "yru"},
	{1, "ybru"},
	
	// Hurt Me Plenty
	{2, "Hurt Me Plenty"},
	{2, "Bringest Them Oneth"},
	{2, "medium"},
	{2, "hmp"},
	{2, "bto"},
	
	// Ultra-Violence
	{3, "Ultra-Violence"},
	{3, "Thou Art A Smite-Meister"},
	{3, "hard"},
	{3, "uv"},
	{3, "taasm"},
	{3, "tasm"},
	
	// Nightmare!
	{4, "Nightmare!"},
	{4, "Black Plague Posseses Thee"},
	{4, "nightmare"},
	{4, "nm"},
	{4, "nmare"},
	{4, "bppt"},
	{4, "plague"},
	
	// End
	{0, "MINVAL"},
	{4, "MAXVAL"},
	{0, NULL},
};

/* c_PEXGSPVKillCountMode -- Kill Count Mode */
const CONL_VarPossibleValue_t c_PEXGSPVKillCountMode[] =
{
	{0, "Always"},
	{1, "Once"},
	{2, "Deads"},
	
	// End
	{0, "MINVAL"},
	{2, "MAXVAL"},
	{0, NULL},
};

/* c_PEXGSPVLastLookMP -- Last Look Modulo */
const CONL_VarPossibleValue_t c_PEXGSPVLastLookMP[] =
{
	// Powers of 2
	{1, "1"},
	{2, "2"},
	{4, "4"},
	{8, "8"},
	{16, "16"},
	{32, "32"},	
	
	// End
	{1, "MINVAL"},
	{MAXPLAYERS, "MAXVAL"},
	{0, NULL},
};

// l_NiceVersions -- Nice names for versions
static const P_XGSNiceVersion_t l_NiceVersions[] =
{
	// Standard Doom
	{109, "Doom v1.9"},
	{110, "Linux Doom"},
	
	// Doom Legacy
	{111, "Doom Legacy 1.11"},
	{112, "Doom Legacy 1.12"},
	{123, "Doom Legacy 1.23"},
	{125, "Doom Legacy 1.25"},
	{128, "Doom Legacy 1.28"},
	{129, "Doom Legacy 1.29"},
	{131, "Doom Legacy 1.31"},
	{132, "Doom Legacy 1.32"},
	{140, "Doom Legacy 1.40"},
	{141, "Doom Legacy 1.41"},
	{142, "Doom Legacy 1.42"},
	
	// ReMooD
	{200, "ReMooD 1.0a"},
	
	{0, NULL},
};

/* P_XGSChangeFunc_ITEMSKEEPWEAPONS() -- ITEMSKEEPWEAPONS Changed */
void P_XGSChangeFunc_ITEMSKEEPWEAPONS(struct P_XGSVariable_s* const a_Bit)
{
	/* Weapons are now being keeped */
	// So respawn them all
	if (P_XGSVal(PGS_ITEMSKEEPWEAPONS))
		P_RespawnWeapons();
}

/* P_XGSChangeFunc_GAMEFRAGLIMIT() -- Frag Limit */
void P_XGSChangeFunc_GAMEFRAGLIMIT(struct P_XGSVariable_s* const a_Bit)
{
	size_t i;
	
	/* See if the frag limit has been exceeded at all */
	if (P_XGSVal(PGS_GAMEFRAGLIMIT))
		for (i = 0; i < MAXPLAYERS; i++)
			P_CheckFragLimit(&players[i]);
}

// l_GSVars -- Game state variables
	// NOTE THAT DOCUMENTATION THE OLDER YOU GET GETS MORE SCARCE AND MORE
	// LESS INFORMATIVE THE FURTHER AWAY INTO THE PAST IT HAS BEEN. SO IF A
	// VERSION IDENTIFIER IS HERE AND YOU HAVE PROOF THAT IT WRONG, THEN PLEASE
	// INFORM ME.
	//
	// However, Luckily for me, Doom Legacy v1.11's source (the first version)
	// is in idgames (sources/doomlegacy1_src.zip) and Fraggle gave me the
	// source to 1.25. There is a huge hole in between because the source was
	// never really released and if it ever was, it was lost.
static P_XGSVariable_t l_GSVars[PEXGSNUMBITIDS] =
{
	{PEXGST_INTEGER, PGS_NOTHINGHERE, "nothinghere", DSTR_M_PGS_NOTHINGHERE,
		DSTR_D_PGS_NOTHINGHERE, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_NONE, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLEBLOODSPLATS, "co_enablebloodsplats", DSTR_M_PGS_COENABLEBLOODSPLATS,
		DSTR_D_PGS_COENABLEBLOODSPLATS, PEXGSGM_ANY, PEXGSDR_ATLEAST, 129, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CORANDOMLASTLOOK, "co_randomlastlook", DSTR_M_PGS_CORANDOMLASTLOOK,
		DSTR_D_PGS_CORANDOMLASTLOOK, PEXGSGM_ANY, PEXGSDR_ATLEAST, 129, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COUNSHIFTVILERAISE, "co_unshiftvileraise", DSTR_M_PGS_COUNSHIFTVILERAISE,
		DSTR_D_PGS_COUNSHIFTVILERAISE, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 129, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMODIFYCORPSE, "co_modifycorpse", DSTR_M_PGS_COMODIFYCORPSE,
		DSTR_D_PGS_COMODIFYCORPSE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 131, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONOSMOKETRAILS, "co_nosmoketrails", DSTR_M_PGS_CONOSMOKETRAILS,
		DSTR_D_PGS_CONOSMOKETRAILS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 111, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COUSEREALSMOKE, "co_userealsmoke", DSTR_M_PGS_COUSEREALSMOKE,
		DSTR_D_PGS_COUSEREALSMOKE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDCUTCORPSERADIUS, "co_oldcutcorpseradius", DSTR_M_PGS_COOLDCUTCORPSERADIUS,
		DSTR_D_PGS_COOLDCUTCORPSERADIUS, PEXGSGM_ANY, PEXGSDR_GREATERTHAN, 112, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COSPAWNDROPSONMOFLOORZ, "co_spawndropsonmofloorz", DSTR_M_PGS_COSPAWNDROPSONMOFLOORZ,
		DSTR_D_PGS_COSPAWNDROPSONMOFLOORZ, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CODISABLETEAMPLAY, "co_disableteamplay", DSTR_M_PGS_CODISABLETEAMPLAY,
		DSTR_D_PGS_CODISABLETEAMPLAY, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 125, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COSLOWINWATER, "co_moveslowinwater", DSTR_M_PGS_COSLOWINWATER,
		DSTR_D_PGS_COSLOWINWATER, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COSLIDEOFFMOFLOOR, "co_slideoffmofloor", DSTR_M_PGS_COSLIDEOFFMOFLOOR,
		DSTR_D_PGS_COSLIDEOFFMOFLOOR, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDFRICTIONMOVE, "co_oldfrictionmove", DSTR_M_PGS_COOLDFRICTIONMOVE,
		DSTR_D_PGS_COOLDFRICTIONMOVE, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 132, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOUCHONCEILING, "co_ouchonceiling", DSTR_M_PGS_COOUCHONCEILING,
		DSTR_D_PGS_COOUCHONCEILING, PEXGSGM_ANY, PEXGSDR_ATLEAST, 112, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLESPLASHES, "co_enablesplashes", DSTR_M_PGS_COENABLESPLASHES,
		DSTR_D_PGS_COENABLESPLASHES, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLEFLOORSMOKE, "co_enablefloorsmoke", DSTR_M_PGS_COENABLEFLOORSMOKE,
		DSTR_D_PGS_COENABLEFLOORSMOKE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLESMOKE, "co_enablesmoke", DSTR_M_PGS_COENABLESMOKE,
		DSTR_D_PGS_COENABLESMOKE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CODAMAGEONLAND, "co_damageonland", DSTR_M_PGS_CODAMAGEONLAND,
		DSTR_D_PGS_CODAMAGEONLAND, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COABSOLUTEANGLE, "co_absoluteangle", DSTR_M_PGS_COABSOLUTEANGLE,
		DSTR_D_PGS_COABSOLUTEANGLE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDJUMPOVER, "co_oldjumpover", DSTR_M_PGS_COOLDJUMPOVER,
		DSTR_D_PGS_COOLDJUMPOVER, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 128, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLESPLATS, "co_enablesplats", DSTR_M_PGS_COENABLESPLATS,
		DSTR_D_PGS_COENABLESPLATS, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDFLATPUSHERCODE, "co_oldflatpushercode", DSTR_M_PGS_COOLDFLATPUSHERCODE,
		DSTR_D_PGS_COOLDFLATPUSHERCODE, PEXGSGM_ANY, PEXGSDR_ATMOST, 140, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COSPAWNPLAYERSEARLY, "co_spawnplayersearly", DSTR_M_PGS_COSPAWNPLAYERSEARLY,
		DSTR_D_PGS_COSPAWNPLAYERSEARLY, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLEUPDOWNSHOOT, "co_enableupdownshoot", DSTR_M_PGS_COENABLEUPDOWNSHOOT,
		DSTR_D_PGS_COENABLEUPDOWNSHOOT, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONOUNDERWATERCHECK, "co_nounderwatercheck", DSTR_M_PGS_CONOUNDERWATERCHECK,
		DSTR_D_PGS_CONOUNDERWATERCHECK, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 128, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COSPLASHTRANSWATER, "co_transwatersplash", DSTR_M_PGS_COSPLASHTRANSWATER,
		DSTR_D_PGS_COSPLASHTRANSWATER, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COUSEOLDZCHECK, "co_useoldzcheck", DSTR_M_PGS_COUSEOLDZCHECK,
		DSTR_D_PGS_COUSEOLDZCHECK, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 131, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COCHECKXYMOVE, "co_checkxymove", DSTR_M_PGS_COCHECKXYMOVE,
		DSTR_D_PGS_COCHECKXYMOVE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 112, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COWATERZFRICTION, "co_waterzfriction", DSTR_M_PGS_COWATERZFRICTION,
		DSTR_D_PGS_COWATERZFRICTION, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CORANOMLASTLOOKSPAWN, "co_randomlastlookspawn", DSTR_M_PGS_CORANOMLASTLOOKSPAWN,
		DSTR_D_PGS_CORANOMLASTLOOKSPAWN, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 129, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COALWAYSRETURNDEADSPMISSILE, "co_alwaysretdeadspmissile", DSTR_M_PGS_COALWAYSRETURNDEADSPMISSILE,
		DSTR_D_PGS_COALWAYSRETURNDEADSPMISSILE, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 131, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COUSEMOUSEAIMING, "co_usemouseaiming", DSTR_M_PGS_COUSEMOUSEAIMING,
		DSTR_D_PGS_COUSEMOUSEAIMING, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COFIXPLAYERMISSILEANGLE, "co_fixplayermissileangle", DSTR_M_PGS_COFIXPLAYERMISSILEANGLE,
		DSTR_D_PGS_COFIXPLAYERMISSILEANGLE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COREMOVEMOINSKYZ, "co_removemissileinskyz", DSTR_M_PGS_COREMOVEMOINSKYZ,
		DSTR_D_PGS_COREMOVEMOINSKYZ, PEXGSGM_ANY, PEXGSDR_ATLEAST, 129, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COFORCEAUTOAIM, "co_forceautoaim", DSTR_M_PGS_COFORCEAUTOAIM,
		DSTR_D_PGS_COFORCEAUTOAIM, PEXGSGM_ANY, PEXGSDR_ATMOST, 111, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COFORCEBERSERKSWITCH, "co_forceberserkswitch", DSTR_M_PGS_COFORCEBERSERKSWITCH,
		DSTR_D_PGS_COFORCEBERSERKSWITCH, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 128, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CODOUBLEPICKUPCHECK, "co_doublepickupcheck", DSTR_M_PGS_CODOUBLEPICKUPCHECK,
		DSTR_D_PGS_CODOUBLEPICKUPCHECK, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CODISABLEMISSILEIMPACTCHECK, "co_disablemissileimpactcheck", DSTR_M_PGS_CODISABLEMISSILEIMPACTCHECK,
		DSTR_D_PGS_CODISABLEMISSILEIMPACTCHECK, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 132, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMISSILESPLATONWALL, "co_missilesplatsonwalls", DSTR_M_PGS_COMISSILESPLATONWALL,
		DSTR_D_PGS_COMISSILESPLATONWALL, PEXGSGM_ANY, PEXGSDR_ATLEAST, 129, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONEWBLOODHITSCANCODE, "co_newbloodhitscancode", DSTR_M_PGS_CONEWBLOODHITSCANCODE,
		DSTR_D_PGS_CONEWBLOODHITSCANCODE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONEWAIMINGCODE, "co_newaimingcode", DSTR_M_PGS_CONEWAIMINGCODE,
		DSTR_D_PGS_CONEWAIMINGCODE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMISSILESPECHIT, "co_missilespechit", DSTR_M_PGS_COMISSILESPECHIT,
		DSTR_D_PGS_COMISSILESPECHIT, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COHITSCANSSLIDEONFLATS, "co_hitscanslidesonflats", DSTR_M_PGS_COHITSCANSSLIDEONFLATS,
		DSTR_D_PGS_COHITSCANSSLIDEONFLATS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 112, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONONSOLIDPASSTHRUOLD, "co_nonsolidpassthruold", DSTR_M_PGS_CONONSOLIDPASSTHRUOLD,
		DSTR_D_PGS_CONONSOLIDPASSTHRUOLD, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 112, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONONSOLIDPASSTHRUNEW, "co_nonsolidpassthrunew", DSTR_M_PGS_CONONSOLIDPASSTHRUNEW,
		DSTR_D_PGS_CONONSOLIDPASSTHRUNEW, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COJUMPCHECK, "co_checkjumpover", DSTR_M_PGS_COJUMPCHECK,
		DSTR_D_PGS_COJUMPCHECK, PEXGSGM_ANY, PEXGSDR_ATLEAST, 112, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COLINEARMAPTRAVERSE, "co_linearmaptraverse", DSTR_M_PGS_COLINEARMAPTRAVERSE,
		DSTR_D_PGS_COLINEARMAPTRAVERSE, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 129, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COONLYTWENTYDMSPOTS, "co_onlytwentydmspots", DSTR_M_PGS_COONLYTWENTYDMSPOTS,
		DSTR_D_PGS_COONLYTWENTYDMSPOTS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 123, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COALLOWSTUCKSPAWNS, "co_allowstuckspawns", DSTR_M_PGS_COALLOWSTUCKSPAWNS,
		DSTR_D_PGS_COALLOWSTUCKSPAWNS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 113, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COUSEOLDBLOOD, "co_useoldblood", DSTR_M_PGS_COUSEOLDBLOOD,
		DSTR_D_PGS_COUSEOLDBLOOD, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 130, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_FUNMONSTERFFA, "fun_monsterffa", DSTR_M_PGS_FUNMONSTERFFA,
		DSTR_D_PGS_FUNMONSTERFFA, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_FUN, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_FUNINFIGHTING, "fun_monsterinfight", DSTR_M_PGS_FUNINFIGHTING,
		DSTR_D_PGS_FUNINFIGHTING, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_FUN, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COCORRECTVILETARGET, "co_correctviletarget", DSTR_M_PGS_COCORRECTVILETARGET,
		DSTR_D_PGS_COCORRECTVILETARGET, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_FUNMONSTERSMISSMORE, "fun_monstersmissmore", DSTR_M_PGS_FUNMONSTERSMISSMORE,
		DSTR_D_PGS_FUNMONSTERSMISSMORE, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_FUN, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMORECRUSHERBLOOD, "co_morecrusherblood", DSTR_M_PGS_COMORECRUSHERBLOOD,
		DSTR_D_PGS_COMORECRUSHERBLOOD, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 132, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CORANDOMBLOODDIR, "co_randomblooddir", DSTR_M_PGS_CORANDOMBLOODDIR,
		DSTR_D_PGS_CORANDOMBLOODDIR, PEXGSGM_ANY, PEXGSDR_ATLEAST, 128, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COINFINITEROCKETZ, "co_infiniterocketz", DSTR_M_PGS_COINFINITEROCKETZ,
		DSTR_D_PGS_COINFINITEROCKETZ, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 112, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COALLOWROCKETJUMPING, "co_allowrocketjump", DSTR_M_PGS_COALLOWROCKETJUMPING,
		DSTR_D_PGS_COALLOWROCKETJUMPING, PEXGSGM_ANY, PEXGSDR_ATLEAST, 129, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COROCKETZTHRUST, "co_rocketzthrust", DSTR_M_PGS_COROCKETZTHRUST,
		DSTR_D_PGS_COROCKETZTHRUST, PEXGSGM_ANY, PEXGSDR_ATLEAST, 124, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COLIMITMONSTERZMATTACK, "co_limitmonsterzmattack", DSTR_M_PGS_COLIMITMONSTERZMATTACK,
		DSTR_D_PGS_COLIMITMONSTERZMATTACK, PEXGSGM_ANY, PEXGSDR_MORETHAN, 111, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_HEREMONSTERTHRESH, "here_monsterthresh", DSTR_M_PGS_HEREMONSTERTHRESH,
		DSTR_D_PGS_HEREMONSTERTHRESH, PEXGSGM_HERETIC, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_HERETIC, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COVOODOODOLLS, "co_voodoodolls", DSTR_M_PGS_COVOODOODOLLS,
		DSTR_D_PGS_COVOODOODOLLS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 128, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COEXTRATRAILPUFF, "co_extratrailpuff", DSTR_M_PGS_COEXTRATRAILPUFF,
		DSTR_D_PGS_COEXTRATRAILPUFF, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 125, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COLOSTSOULTRAILS, "co_lostsoultrails", DSTR_M_PGS_COLOSTSOULTRAILS,
		DSTR_D_PGS_COLOSTSOULTRAILS, PEXGSGM_ANY, PEXGSDR_ATLEAST, 125, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COTRANSTWOSIDED, "co_transtwosided", DSTR_M_PGS_COTRANSTWOSIDED,
		DSTR_D_PGS_COTRANSTWOSIDED, PEXGSGM_ANY, PEXGSDR_EQUALS, 111, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLEBLOODTIME, "co_enablebloodtime", DSTR_M_PGS_COENABLEBLOODTIME,
		DSTR_D_PGS_COENABLEBLOODTIME, PEXGSGM_ANY, PEXGSDR_ATLEAST, 123, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLENABLEJUMPING, "pl_enablejumping", DSTR_M_PGS_PLENABLEJUMPING,
		DSTR_D_PGS_PLENABLEJUMPING, PEXGSGM_ANY, PEXGSDR_ATLEAST, 112, {0, 1}, 1,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMOUSEAIM, "co_mouseaim", DSTR_M_PGS_COMOUSEAIM,
		DSTR_D_PGS_COMOUSEAIM, PEXGSGM_ANY, PEXGSDR_MORETHAN, 111, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONRESPAWNMONSTERS, "mon_respawnmonsters", DSTR_M_PGS_MONRESPAWNMONSTERS,
		DSTR_D_PGS_MONRESPAWNMONSTERS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_MONSTERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_FUNNOTARGETPLAYER, "fun_noplayertarget", DSTR_M_PGS_FUNNOTARGETPLAYER,
		DSTR_D_PGS_FUNNOTARGETPLAYER, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_FUN, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONARCHVILEANYRESPAWN, "mon_archvileanyrespawn", DSTR_M_PGS_MONARCHVILEANYRESPAWN,
		DSTR_D_PGS_MONARCHVILEANYRESPAWN, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_FUN, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDCHECKPOSITION, "co_oldcheckposition", DSTR_M_PGS_COOLDCHECKPOSITION,
		DSTR_D_PGS_COOLDCHECKPOSITION, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 142, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COLESSSPAWNSTICKING, "co_lessspawnsticking", DSTR_M_PGS_COLESSSPAWNSTICKING,
		DSTR_D_PGS_COLESSSPAWNSTICKING, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNTELEFRAG, "pl_spawntelefrag", DSTR_M_PGS_PLSPAWNTELEFRAG,
		DSTR_D_PGS_PLSPAWNTELEFRAG, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMEONEHITKILLS, "game_onehitkills", DSTR_M_PGS_GAMEONEHITKILLS,
		DSTR_D_PGS_GAMEONEHITKILLS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_GAME, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COBETTERPLCORPSEREMOVAL, "co_betterplbodyqueue", DSTR_M_PGS_COBETTERPLCORPSEREMOVAL,
		DSTR_D_PGS_COBETTERPLCORPSEREMOVAL, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNCLUSTERING, "pl_spawnclustering", DSTR_M_PGS_PLSPAWNCLUSTERING,
		DSTR_D_PGS_PLSPAWNCLUSTERING, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COIMPROVEDMOBJONMOBJ, "co_improvedmobjonmobj", DSTR_M_PGS_COIMPROVEDMOBJONMOBJ,
		DSTR_D_PGS_COIMPROVEDMOBJONMOBJ, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 0}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COIMPROVEPATHTRAVERSE, "co_improvepathtraverse", DSTR_M_PGS_COIMPROVEPATHTRAVERSE,
		DSTR_D_PGS_COIMPROVEPATHTRAVERSE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_FLOAT, PGS_PLJUMPGRAVITY, "pl_jumpgravity", DSTR_M_PGS_PLJUMPGRAVITY,
		DSTR_D_PGS_PLJUMPGRAVITY, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, (6 * FRACUNIT)}, (6 * FRACUNIT),
		PEXGSMC_PLAYERS, 0, c_PEXGSPVFixed, NULL},

	{PEXGST_INTEGER, PGS_FUNNOLOCKEDDOORS, "fun_nolockeddoors", DSTR_M_PGS_FUNNOLOCKEDDOORS,
		DSTR_D_PGS_FUNNOLOCKEDDOORS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_FUN, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_FLOAT, PGS_GAMEAIRFRICTION, "game_airfriction", DSTR_M_PGS_GAMEAIRFRICTION,
		DSTR_D_PGS_GAMEAIRFRICTION, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 8192}, 8192,
		PEXGSMC_GAME, 0, c_PEXGSPVFixed, NULL},

	{PEXGST_FLOAT, PGS_GAMEWATERFRICTION, "game_waterfriction", DSTR_M_PGS_GAMEWATERFRICTION,
		DSTR_D_PGS_GAMEWATERFRICTION, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 49152}, 49152,
		PEXGSMC_GAME, 0, c_PEXGSPVFixed, NULL},

	{PEXGST_FLOAT, PGS_GAMEMIDWATERFRICTION, "game_midwaterfriction", DSTR_M_PGS_GAMEMIDWATERFRICTION,
		DSTR_D_PGS_GAMEMIDWATERFRICTION, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 32768}, 32768,
		PEXGSMC_GAME, 0, c_PEXGSPVFixed, NULL},

	{PEXGST_INTEGER, PGS_GAMEALLOWLEVELEXIT, "game_allowlevelexit", DSTR_M_PGS_GAMEALLOWLEVELEXIT,
		DSTR_D_PGS_GAMEALLOWLEVELEXIT, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 1,
		PEXGSMC_GAME, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMEALLOWROCKETJUMP, "game_allowrocketjump", DSTR_M_PGS_GAMEALLOWROCKETJUMP,
		DSTR_D_PGS_GAMEALLOWROCKETJUMP, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_GAME, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLALLOWAUTOAIM, "pl_allowautoaim", DSTR_M_PGS_PLALLOWAUTOAIM,
		DSTR_D_PGS_PLALLOWAUTOAIM, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 1,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLFORCEWEAPONSWITCH, "pl_forceweaponswitch", DSTR_M_PGS_PLFORCEWEAPONSWITCH,
		DSTR_D_PGS_PLFORCEWEAPONSWITCH, PEXGSGM_ANY, PEXGSDR_ATMOST, 109, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLDROPWEAPONS, "pl_dropweapons", DSTR_M_PGS_PLDROPWEAPONS,
		DSTR_D_PGS_PLDROPWEAPONS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLINFINITEAMMO, "pl_infiniteammo", DSTR_M_PGS_PLINFINITEAMMO,
		DSTR_D_PGS_PLINFINITEAMMO, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMEHERETICGIBBING, "game_hereticgibbing", DSTR_M_PGS_GAMEHERETICGIBBING,
		DSTR_D_PGS_GAMEHERETICGIBBING, PEXGSGM_HERETIC, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_HERETIC, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONPREDICTMISSILES, "mon_predictmissile", DSTR_M_PGS_MONPREDICTMISSILES,
		DSTR_D_PGS_MONPREDICTMISSILES, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_MONSTERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONRESPAWNMONSTERSTIME, "mon_respawnmonsterstime", DSTR_M_PGS_MONRESPAWNMONSTERSTIME,
		DSTR_D_PGS_MONRESPAWNMONSTERSTIME, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 12}, 12,
		PEXGSMC_MONSTERS, PEXGSDA_TIMESECS, c_PEXGSPVPositive, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNWITHMAXGUNS, "pl_spawnwithmaxguns", DSTR_M_PGS_PLSPAWNWITHMAXGUNS,
		DSTR_D_PGS_PLSPAWNWITHMAXGUNS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNWITHSUPERGUNS, "pl_spawnwithsuperguns", DSTR_M_PGS_PLSPAWNWITHSUPERGUNS,
		DSTR_D_PGS_PLSPAWNWITHSUPERGUNS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNWITHMAXSTATS, "pl_spawnwithmaxstats", DSTR_M_PGS_PLSPAWNWITHMAXSTATS,
		DSTR_D_PGS_PLSPAWNWITHMAXSTATS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_ITEMSSPAWNPICKUPS, "item_spawnpickups", DSTR_M_PGS_ITEMSSPAWNPICKUPS,
		DSTR_D_PGS_ITEMSSPAWNPICKUPS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 1,
		PEXGSMC_ITEMS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COHERETICFRICTION, "co_hereticfriction", DSTR_M_PGS_COHERETICFRICTION,
		DSTR_D_PGS_COHERETICFRICTION, PEXGSGM_HERETIC, PEXGSDR_ATLEAST, 0, {0, 1}, 0,
		PEXGSMC_HERETIC, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMEDEATHMATCH, "game_deathmatch", DSTR_M_PGS_GAMEDEATHMATCH,
		DSTR_D_PGS_GAMEDEATHMATCH, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_GAME, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNWITHALLKEYS, "pl_spawnwithallkeys", DSTR_M_PGS_PLSPAWNWITHALLKEYS,
		DSTR_D_PGS_PLSPAWNWITHALLKEYS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_ITEMSKEEPWEAPONS, "item_keepweapons", DSTR_M_PGS_ITEMSKEEPWEAPONS,
		DSTR_D_PGS_ITEMSKEEPWEAPONS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_ITEMS, PEXGSDA_YESNO, c_PEXGSPVBoolean, P_XGSChangeFunc_ITEMSKEEPWEAPONS},

	{PEXGST_INTEGER, PGS_GAMETEAMPLAY, "game_teamplay", DSTR_M_PGS_GAMETEAMPLAY,
		DSTR_D_PGS_GAMETEAMPLAY, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_GAME, PEXGSDA_STRING, c_PEXGSPVTeamPlay, NULL},

	{PEXGST_INTEGER, PGS_GAMETEAMDAMAGE, "game_teamdamage", DSTR_M_PGS_GAMETEAMDAMAGE,
		DSTR_D_PGS_GAMETEAMDAMAGE, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_GAME, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMEFRAGLIMIT, "game_fraglimit", DSTR_M_PGS_GAMEFRAGLIMIT,
		DSTR_D_PGS_GAMEFRAGLIMIT, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_GAME, PEXGSDA_INTEGER, c_PEXGSPVPositive, P_XGSChangeFunc_GAMEFRAGLIMIT},

	{PEXGST_INTEGER, PGS_GAMETIMELIMIT, "game_timelimit", DSTR_M_PGS_GAMETIMELIMIT,
		DSTR_D_PGS_GAMETIMELIMIT, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_GAME, PEXGSDA_TIMEMINS, c_PEXGSPVPositive, NULL},

	{PEXGST_INTEGER, PGS_MONSTATICRESPAWNTIME, "mon_staticrespawntime", DSTR_M_PGS_MONSTATICRESPAWNTIME,
		DSTR_D_PGS_MONSTATICRESPAWNTIME, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_MONSTERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLFASTERWEAPONS, "pl_fasterweapons", DSTR_M_PGS_PLFASTERWEAPONS,
		DSTR_D_PGS_PLFASTERWEAPONS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONSPAWNMONSTERS, "mon_spawnmonsters", DSTR_M_PGS_MONSPAWNMONSTERS,
		DSTR_D_PGS_MONSPAWNMONSTERS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 1,
		PEXGSMC_MONSTERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMESPAWNMULTIPLAYER, "game_spawnmultiplayer", DSTR_M_PGS_GAMESPAWNMULTIPLAYER,
		DSTR_D_PGS_GAMESPAWNMULTIPLAYER, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_GAME, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_ITEMRESPAWNITEMS, "item_respawnitems", DSTR_M_PGS_ITEMRESPAWNITEMS,
		DSTR_D_PGS_ITEMRESPAWNITEMS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_ITEMS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_ITEMRESPAWNITEMSTIME, "item_respawnitemstime", DSTR_M_PGS_ITEMRESPAWNITEMSTIME,
		DSTR_D_PGS_ITEMRESPAWNITEMSTIME, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 30}, 30,
		PEXGSMC_ITEMS, PEXGSDA_TIMESECS, c_PEXGSPVPositive, NULL},

	{PEXGST_INTEGER, PGS_MONFASTMONSTERS, "mon_spawnmonsters", DSTR_M_PGS_MONFASTMONSTERS,
		DSTR_D_PGS_MONFASTMONSTERS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_MONSTERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMESOLIDCORPSES, "game_solidcorpses", DSTR_M_PGS_GAMESOLIDCORPSES,
		DSTR_D_PGS_GAMESOLIDCORPSES, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_GAME, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_GAMEBLOODTIME, "game_bloodtime", DSTR_M_PGS_GAMEBLOODTIME,
		DSTR_D_PGS_GAMEBLOODTIME, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 20}, 20,
		PEXGSMC_GAME, PEXGSDA_TIMESECS, c_PEXGSPVPositive, NULL},

	{PEXGST_FLOAT, PGS_GAMEGRAVITY, "game_gravity", DSTR_M_PGS_GAMEGRAVITY,
		DSTR_D_PGS_GAMEGRAVITY, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, (1 * FRACUNIT)}, (1 * FRACUNIT),
		PEXGSMC_GAME, 0, c_PEXGSPVFixed, NULL},

	{PEXGST_INTEGER, PGS_MONENABLECLEANUP, "mon_enablecleanup", DSTR_M_PGS_MONENABLECLEANUP,
		DSTR_D_PGS_MONENABLECLEANUP, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_MONSTERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONCLEANUPRESPTIME, "mon_cleanupresptime", DSTR_M_PGS_MONCLEANUPRESPTIME,
		DSTR_D_PGS_MONCLEANUPRESPTIME, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 120}, 120,
		PEXGSMC_MONSTERS, PEXGSDA_TIMEMINS, c_PEXGSPVPositive, NULL},

	{PEXGST_INTEGER, PGS_MONCLEANUPNONRTIME, "mon_cleanupnonresptime", DSTR_M_PGS_MONCLEANUPNONRTIME,
		DSTR_D_PGS_MONCLEANUPNONRTIME, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 60}, 60,
		PEXGSMC_MONSTERS, PEXGSDA_TIMEMINS, c_PEXGSPVPositive, NULL},

	{PEXGST_INTEGER, PGS_GAMESKILL, "game_skill", DSTR_M_PGS_GAMESKILL,
		DSTR_D_PGS_GAMESKILL, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 2}, 2,
		PEXGSMC_GAME, PEXGSDA_STRING, c_PEXGSPVSkill, NULL},

	{PEXGST_INTEGER, PGS_PLHALFDAMAGE, "pl_halfdamage", DSTR_M_PGS_PLHALFDAMAGE,
		DSTR_D_PGS_PLHALFDAMAGE, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLDOUBLEAMMO, "pl_doubleammo", DSTR_M_PGS_PLDOUBLEAMMO,
		DSTR_D_PGS_PLDOUBLEAMMO, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONKILLCOUNTMODE, "mon_killcountmode", DSTR_M_PGS_MONKILLCOUNTMODE,
		DSTR_D_PGS_MONKILLCOUNTMODE, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_MONSTERS, PEXGSDA_STRING, c_PEXGSPVKillCountMode, NULL},
	
	// Old BFG Spray in ReMooD, but not before
	{PEXGST_INTEGER, PGS_COOLDBFGSPRAY, "co_oldbfgspray", DSTR_M_PGS_COOLDBFGSPRAY,
		DSTR_D_PGS_COOLDBFGSPRAY, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COEXPLODEHITFLOOR, "co_explodehitfloor", DSTR_M_PGS_COEXPLODEHITFLOOR,
		DSTR_D_PGS_COEXPLODEHITFLOOR, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COBOMBTHRUFLOOR, "co_bombthrufloor", DSTR_M_PGS_COBOMBTHRUFLOOR,
		DSTR_D_PGS_COBOMBTHRUFLOOR, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 132, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDEXPLOSIONS, "co_oldexplosions", DSTR_M_PGS_COOLDEXPLOSIONS,
		DSTR_D_PGS_COOLDEXPLOSIONS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 132, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COAIMCHECKFAKEFLOOR, "co_aimcheckfakefloor", DSTR_M_PGS_COAIMCHECKFAKEFLOOR,
		DSTR_D_PGS_COAIMCHECKFAKEFLOOR, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONEWGUNSHOTCODE, "co_newgunshotcode", DSTR_M_PGS_CONEWGUNSHOTCODE,
		DSTR_D_PGS_CONEWGUNSHOTCODE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COSHOOTCHECKFAKEFLOOR, "co_shootcheckfakefloor", DSTR_M_PGS_COSHOOTCHECKFAKEFLOOR,
		DSTR_D_PGS_COSHOOTCHECKFAKEFLOOR, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COSHOOTFLOORCLIPPING, "co_shootfloorclipping", DSTR_M_PGS_COSHOOTFLOORCLIPPING,
		DSTR_D_PGS_COSHOOTFLOORCLIPPING, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONEWSSGSPREAD, "co_newssgspread", DSTR_M_PGS_CONEWSSGSPREAD,
		DSTR_D_PGS_CONEWSSGSPREAD, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMONSTERLOOKFORMONSTER, "co_monsterlookmonster", DSTR_M_PGS_COMONSTERLOOKFORMONSTER,
		DSTR_D_PGS_COMONSTERLOOKFORMONSTER, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDTHINGHEIGHTS, "co_oldthingheights", DSTR_M_PGS_COOLDTHINGHEIGHTS,
		DSTR_D_PGS_COOLDTHINGHEIGHTS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 132, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COLASTLOOKMAXPLAYERS, "co_lastlookmaxplayers", DSTR_M_PGS_COLASTLOOKMAXPLAYERS,
		DSTR_D_PGS_COLASTLOOKMAXPLAYERS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {32, 32}, 32,
		PEXGSMC_COMPAT, PEXGSDA_INTEGER, c_PEXGSPVLastLookMP, NULL},

	{PEXGST_INTEGER, PGS_COMOVECHECKFAKEFLOOR, "co_movecheckfakefloor", DSTR_M_PGS_COMOVECHECKFAKEFLOOR,
		DSTR_D_PGS_COMOVECHECKFAKEFLOOR, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMULTIPLAYER, "co_multiplayer", DSTR_M_PGS_COMULTIPLAYER,
		DSTR_D_PGS_COMULTIPLAYER, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COBOOMSUPPORT, "co_boomsupport", DSTR_M_PGS_COBOOMSUPPORT,
		DSTR_D_PGS_COBOOMSUPPORT, PEXGSGM_ANY, PEXGSDR_ATLEAST, 132, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNWITHFAVGUN, "pl_spawnwithfavgun", DSTR_M_PGS_PLSPAWNWITHFAVGUN,
		DSTR_D_PGS_PLSPAWNWITHFAVGUN, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_CONOSAWFACING, "co_nosawfacing", DSTR_M_PGS_CONOSAWFACING,
		DSTR_D_PGS_CONOSAWFACING, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},	

	{PEXGST_INTEGER, PGS_COENABLETEAMMONSTERS, "co_enableteammonsters", DSTR_M_PGS_COENABLETEAMMONSTERS,
		DSTR_D_PGS_COENABLETEAMMONSTERS, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COMONSTERDEADTARGET, "co_monsterdeadtarget", DSTR_M_PGS_COMONSTERDEADTARGET,
		DSTR_D_PGS_COMONSTERDEADTARGET, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COJUMPREGARDLESS, "co_jumpregardless", DSTR_M_PGS_COJUMPREGARDLESS,
		DSTR_D_PGS_COJUMPREGARDLESS, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 200, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COOLDLASTLOOKLOGIC, "co_oldlastlooklogic", DSTR_M_PGS_COOLDLASTLOOKLOGIC,
		DSTR_D_PGS_COOLDLASTLOOKLOGIC, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 130, {0, 1}, 0,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},	

	{PEXGST_INTEGER, PGS_CORADIALSPAWNCHECK, "co_radialspawncheck", DSTR_M_PGS_CORADIALSPAWNCHECK,
		DSTR_D_PGS_CORADIALSPAWNCHECK, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_MONENABLEPLAYASMONSTER, "mon_enableplayasmonster", DSTR_M_PGS_MONENABLEPLAYASMONSTER,
		DSTR_D_PGS_MONENABLEPLAYASMONSTER, PEXGSGM_ANY, PEXGSDR_NOCHECK, 200, {0, 1}, 0,
		PEXGSMC_MONSTERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COKILLSTOPLAYERONE, "co_killstoplayerone", DSTR_M_PGS_COKILLSTOPLAYERONE,
		DSTR_D_PGS_COKILLSTOPLAYERONE, PEXGSGM_ANY, PEXGSDR_LESSTHAN, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLALLOWSUICIDE, "pl_allowsuicide", DSTR_M_PGS_PLALLOWSUICIDE,
		DSTR_D_PGS_PLALLOWSUICIDE, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSUICIDEDELAY, "pl_suicidedelay", DSTR_M_PGS_PLSUICIDEDELAY,
		DSTR_D_PGS_PLSUICIDEDELAY, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 3}, 3,
		PEXGSMC_PLAYERS, PEXGSDA_TIMESECS, c_PEXGSPVPositive, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNWITHMELEEONLY, "pl_spawnwithmeleeonly", DSTR_M_PGS_PLSPAWNWITHMELEEONLY,
		DSTR_D_PGS_PLSPAWNWITHMELEEONLY, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_PLSPAWNWITHRANDOMGUN, "pl_spawnwithrandom", DSTR_M_PGS_PLSPAWNWITHRANDOMGUN,
		DSTR_D_PGS_PLSPAWNWITHRANDOMGUN, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 1}, 0,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},

	{PEXGST_INTEGER, PGS_COENABLESLOPES, "co_enableslopes", DSTR_M_PGS_COENABLESLOPES,
		DSTR_D_PGS_COENABLESLOPES, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},
		
	{PEXGST_INTEGER, PGS_FUNFLIPLEVELS, "fun_fliplevels", DSTR_M_PGS_FUNFLIPLEVELS,
		DSTR_D_PGS_FUNFLIPLEVELS, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 0,
		PEXGSMC_FUN, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},
		
	{PEXGST_INTEGER, PGS_PLREDUCEINVENTORY, "pl_reduceinventory", DSTR_M_PGS_PLREDUCEINVENTORY,
		DSTR_D_PGS_PLREDUCEINVENTORY, PEXGSGM_ANY, PEXGSDR_NOCHECK, 0, {0, 0}, 1,
		PEXGSMC_PLAYERS, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},
		
	{PEXGST_INTEGER, PGS_CODISPLACESPAWN, "co_displacespawning", DSTR_M_PGS_CODISPLACESPAWN,
		DSTR_D_PGS_CODISPLACESPAWN, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},
		
	{PEXGST_INTEGER, PGS_CORESPAWNCORPSESONLY, "co_respawncorpsesonly", DSTR_M_PGS_CORESPAWNCORPSESONLY,
		DSTR_D_PGS_CORESPAWNCORPSESONLY, PEXGSGM_ANY, PEXGSDR_ATLEAST, 200, {0, 1}, 1,
		PEXGSMC_COMPAT, PEXGSDA_YESNO, c_PEXGSPVBoolean, NULL},
};

/*** FUNCTIONS ***/

/* P_XGSBitForName() -- Finds */
P_XGSBitID_t P_XGSBitForName(const char* const a_Name)
{
	P_XGSBitID_t i;
	
	/* Check */
	if (!a_Name)
		return PGS_NOTHINGHERE;
	
	/* Check all names */
	for (i = 1; i < PEXGSNUMBITIDS; i++)
		if (!strcasecmp(a_Name, l_GSVars[i].Name))
			return i;
	
	/* Not Found */
	return PGS_NOTHINGHERE;
}

/* P_XGSVarForBit() -- Get variable for bit */
P_XGSVariable_t* P_XGSVarForBit(const P_XGSBitID_t a_Bit)
{
	size_t i;
	
	/* Check bit */
	if (a_Bit < 0 || a_Bit >= PEXGSNUMBITIDS)
		return NULL;
	
	/* Match? */
	if (a_Bit == l_GSVars[a_Bit].BitID)
		return &l_GSVars[a_Bit];
	
	/* Find it manually */
	for (i = 0; i < PEXGSNUMBITIDS; i++)
		if (a_Bit == l_GSVars[i].BitID)
			return &l_GSVars[i];
	
	/* Not found */
	return NULL;
}

/* P_XGSVarForName() -- Find variable by name */
P_XGSVariable_t* P_XGSVarForName(const char* const a_Name)
{
	size_t i;
	
	/* Check */
	if (!a_Name)
		return NULL;
	
	/* Find it manually */
	for (i = 0; i < PEXGSNUMBITIDS; i++)
		if (strcasecmp(a_Name, l_GSVars[i].Name) == 0)
			return &l_GSVars[i];
	
	/* Not found */
	return NULL;
}

/* P_XGSVal() -- Get value based on bit */
int32_t P_XGSVal(const P_XGSBitID_t a_Bit)
{
	P_XGSVariable_t* Var;
	
	/* Get variable first */
	Var = P_XGSVarForBit(a_Bit);
	
	// Nothing?
	if (!Var)
		return 0;
	
	/* Just return value */
	// Was never set? Return default
	if (!Var->WasSet)
		return Var->DefaultVal;
	
	// Otherwise return to what it was set to
	else
		return Var->ActualVal;
}

/* P_XGSFix() -- Gets fixed_t value */
fixed_t P_XGSFix(const P_XGSBitID_t a_Bit)
{
	return P_XGSVal(a_Bit);
}

/* P_XGSGetNextValue() -- Gets the next value in a certain direction */
int32_t P_XGSGetNextValue(const P_XGSBitID_t a_Bit, const bool_t a_Right)
{
	P_XGSVariable_t* Var;
	int32_t MinVal, MaxVal, ReqVal, i;
	int32_t ixMi, ixMa;
	
	/* Get variable first */
	Var = P_XGSVarForBit(a_Bit);
	
	// Nothing?
	if (!Var)
		return 0;
	
	/* Get Min/Max Values */
	// Possible Values
	ixMi = ixMa = -1;
	if (Var->Possible)
		// Check values and obtain min/max too
		for (i = 0; Var->Possible[i].StrAlias; i++)
		{
			// Min?
			if (strcasecmp("MINVAL", Var->Possible[i].StrAlias) == 0)
			{
				ixMi = i;
				MinVal = Var->Possible[i].IntVal;
			}
			
			// Max?
			else if (strcasecmp("MAXVAL", Var->Possible[i].StrAlias) == 0)
			{
				ixMa = i;
				MaxVal = Var->Possible[i].IntVal;
			}
		}
	
	// There are no possible values
	else
	{
		MinVal = c_PEXGSPVFixed[0].IntVal;
		MaxVal = c_PEXGSPVFixed[1].IntVal;
	}
	
	/* Start at the curernt value */
	if (Var->WasSet)
		ReqVal = Var->ActualVal;
	else
		ReqVal = Var->DefaultVal;
	
	/* Loop until the next is found */
	for (;;)
	{
		// Value at maximum? Return max
		if (a_Right && ReqVal >= MaxVal)
			return MaxVal;
		
		// Value at minimum? Return minimum
		else if (!a_Right && ReqVal <= MinVal)
			return MinVal;
		
		// Move value by single unit
		if (Var->Type == PEXGST_FLOAT)
			ReqVal += 4096 * (a_Right ? 1 : -1);	// Move by .0625
		else
			ReqVal += (a_Right ? 1 : -1);			// Move by 1
		
		// There are no enumerated value ranges
		if (ixMi == 0 || ixMa == 0)
			return ReqVal;
		
		// Hit exact value? Then return it
		else
			for (i = 0; Var->Possible[i].StrAlias; i++)
				if (ReqVal == Var->Possible[i].IntVal)
					return ReqVal;
	}
	
	/* Return the requested value */
	return ReqVal;
}

/* PS_EXGSGeneralComm() -- General command for game settings */
static int PS_EXGSGeneralComm(const uint32_t a_ArgC, const char** const a_ArgV)
{
	size_t i;
	P_XGSVariable_t* Var;
	
	/* Pop Menu */
	if (strcasecmp(a_ArgV[0], "menugamevar") == 0)
	{
		M_ExPushMenu(0, M_ExTemplateMakeGameVars(0));
	}
	
	/* Game Settings Control */
	else if (strcasecmp(a_ArgV[0], "gamevar") == 0)
	{
		// Missing argument? (list all settings)
		if (a_ArgC < 2)
		{
			// Print header
			CONL_PrintF("Game settings:\n");
			
			// Print list
			for (i = 0; i < PEXGSNUMBITIDS; i++)
			{
#if 1
				CONL_PrintF("{4%-30s{z = {6%i{z\n", l_GSVars[i].Name, P_XGSVal(l_GSVars[i].BitID));
#else
				CONL_PrintF("{4%-25s{z\n", l_GSVars[i].Name);
				CONL_PrintF("  : {5%.45s{z\n", l_GSVars[i].Description);
				CONL_PrintF("  = %s\n", l_GSVars[i].StrVal);
#endif
			}
			
			// Success!
			return 0;
		}
		
		// Two Arguments = Get value of setting
		else if (a_ArgC == 2)
		{
			// Find var?
			Var = P_XGSVarForName(a_ArgV[1]);
			
			// Not found?
			if (!Var)
				return 1;
			
			// Return value and information
			CONL_PrintF("{4%-30s{z \"{7%s{z\"\n", Var->Name, DS_GetString(Var->MenuTitle));
			CONL_PrintF("  Desc: %s\n", DS_GetString(Var->Description));
			CONL_PrintF("  Valu: %s (%i)\n", Var->StrVal, P_XGSVal(Var->BitID));
			
			return 0;
		}
		
		// Other arguments = Set value of setting
		else
		{
			// Find var?
			Var = P_XGSVarForName(a_ArgV[1]);
			
			// Not found?
			if (!Var)
				return 1;
			
			// Set value
			P_XGSSetValueStr(false, Var->BitID, a_ArgV[2]);
			
			return 0;
		}
	}
	
	/* Game Compatibility Control */
	else if (strcasecmp(a_ArgV[0], "gameversion") == 0)
	{
		// Missing argument?
		if (a_ArgC < 2)
		{
			// Header
			CONL_PrintF("Compatibility Levels:\n");
			
			// Print possible version numbers
			for (i = 0; l_NiceVersions[i].NiceName || l_NiceVersions[i].VersionID; i++)
			{
				// Print
				CONL_PrintF(" %3i = %s\n", l_NiceVersions[i].VersionID, l_NiceVersions[i].NiceName);
			}
		}
		
		// Otherwise
		else
		{	
			P_XGSSetVersionLevel(false, atoi(a_ArgV[1]));
		}
		
		// Success!
		return 0;
	}
	
	/* Unknown */
	return 1;
}

/* PS_EXGSValToStr() -- Convert Value to String */
static void PS_EXGSValToStr(P_XGSVariable_t* const a_Var)
{
	int32_t XVal, a, b, c;
	
	/* Check */
	if (!a_Var)
		return;
	
	/* Get actual value */
	if (a_Var->WasSet)
		XVal = a_Var->ActualVal;
	else
		XVal = a_Var->DefaultVal;
	
	/* Draw as which? */
	switch (a_Var->Type)
	{
		case PEXGST_INTEGER:
			switch (a_Var->DisplayAs)
			{
					// Yes/No
				case PEXGSDA_YESNO:
					if (XVal)
						strncpy(a_Var->StrVal, "Yes", PEXGSSTRBUFSIZE - 1);
					else
						strncpy(a_Var->StrVal, "No", PEXGSSTRBUFSIZE - 1);
					break;
					
					// Time in Minutes
				case PEXGSDA_TIMEMINS:
					// Minutes
					a = XVal % 60;
					
					// Hours
					b = (XVal / 60) % 24;
					
					// Days
					c = (XVal / 60) / 24;
					
					// Minutes Only
					if (!b && !c)
						snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%i m", a);
						
					// Minutes and Hours
					else if (!c)
						snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%i h %i m", b, a);
					
					// Minutes, Hours, Days
					else
						snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%i d %i h %i m", c, b, a);
					break;
					
					// Time in Seconds -- Spaces due to readability issues
				case PEXGSDA_TIMESECS:
					// Seconds
					a = XVal % 60;
					
					// Minutes
					b = (XVal / 60) % 60;
					
					// Hours
					c = (XVal / 60) / 60;
					
					// Seconds Only
					if (!b && !c)
						snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%i s", a);
						
					// Seconds and Minutes
					else if (!c)
						snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%i m %i s", b, a);
					
					// Seconds, Minutes, Hours
					else
						snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%i h %i m %i s", c, b, a);
					break;
					
					// String Value
				case PEXGSDA_STRING:
					// Clear away
					a_Var->StrVal[0] = 0;
					
					// Get Value?
					if (a_Var->Possible)
						for (a = 0; a_Var->Possible[a].StrAlias; a++)
							if (a_Var->Possible[a].IntVal == XVal)
							{
								strncpy(a_Var->StrVal, a_Var->Possible[a].StrAlias, PEXGSSTRBUFSIZE - 1);
								break;
							}
					
					// Missing?
					if (!a_Var->StrVal[0])
						strncpy(a_Var->StrVal, "???", PEXGSSTRBUFSIZE - 1);
					break;
				
					// Plain Integer
				case PEXGSDA_INTEGER:
				default:
					snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%i\n", XVal);
					break;
			}
			break;
		
		case PEXGST_FLOAT:
			snprintf(a_Var->StrVal, PEXGSSTRBUFSIZE - 1, "%g\n", FIXED_TO_FLOAT(XVal));
			break;
		
		default:
			break;
	}
}

/* P_XGSRegisterStuff() -- Register stuff needed for these things */
bool_t P_XGSRegisterStuff(void)
{
	size_t i;
	
	/* Run through all vars and set strings */
	for (i = 0; i < PEXGSNUMBITIDS; i++)
		PS_EXGSValToStr(&l_GSVars[i]);
	
	/* Register game setting commands */
	CONL_AddCommand("menugamevar", PS_EXGSGeneralComm);
	CONL_AddCommand("gamevar", PS_EXGSGeneralComm);
	CONL_AddCommand("gameversion", PS_EXGSGeneralComm);
	
	/* Always works! */
	return true;
}

/* P_XGSSetAllDefaults() -- Set all values to defaults */
bool_t P_XGSSetAllDefaults(void)
{
	size_t i;
	
	/* Run through the list */
	for (i = 0; i < PEXGSNUMBITIDS; i++)
	{
		// Clear values and unset
		l_GSVars[i].WasSet = 0;
		l_GSVars[i].ActualVal = 0;
		
		// Recreate string
		PS_EXGSValToStr(&l_GSVars[i]);
	}
	
	return true;
}

/* P_XGSSetVersionLevel() -- Set version level to a specific compatibility level */
bool_t P_XGSSetVersionLevel(const bool_t a_Master, const uint32_t a_Level)
{
	size_t i;
	bool_t IsTrue;
	uint16_t CheckVs;
	
	/* Run through the list */
	for (i = 0; i < PEXGSNUMBITIDS; i++)
	{
		// Unset
		IsTrue = false;
		CheckVs = l_GSVars[i].DemoVersion;
		
		// Ignore
		if (l_GSVars[i].DemoRange == PEXGSDR_NOCHECK)
			continue;
		
		// Wrong Game?
		if ((g_CoreGame == CG_DOOM && !(l_GSVars[i].GameFlags & PEXGSGM_DOOM)) ||
			(g_CoreGame == CG_HERETIC && !(l_GSVars[i].GameFlags & PEXGSGM_HERETIC)) ||
			(g_CoreGame == CG_HEXEN && !(l_GSVars[i].GameFlags & PEXGSGM_HEXEN)) ||
			(g_CoreGame == CG_STRIFE && !(l_GSVars[i].GameFlags & PEXGSGM_STRIFE)))
			IsTrue = false;
			
		// Which comparison?
		else
			switch (l_GSVars[i].DemoRange)
			{
				case PEXGSDR_EQUALS:
					if (a_Level == CheckVs)
						IsTrue = true;
					break;
				case PEXGSDR_NOT:
					if (a_Level != CheckVs)
						IsTrue = true;
					break;
				case PEXGSDR_LESSTHAN:
					if (a_Level < CheckVs)
						IsTrue = true;
					break;
				case PEXGSDR_GREATERTHAN:
					if (a_Level > CheckVs)
						IsTrue = true;
					break;
				case PEXGSDR_ATMOST:
					if (a_Level <= CheckVs)
						IsTrue = true;
					break;
				case PEXGSDR_ATLEAST:
					if (a_Level >= CheckVs)
						IsTrue = true;
					break;
				default:
					IsTrue = false;
					break;
			}
		
		// Set value
		P_XGSSetValue(a_Master, l_GSVars[i].BitID, l_GSVars[i].DemoVal[IsTrue]);
	}
	
	/* Complex stuff */
	if (a_Level <= 109)
		P_XGSSetValue(a_Master, PGS_GAMETEAMDAMAGE, 1);
	
	if (a_Level <= 109)
		P_XGSSetValue(a_Master, PGS_GAMEHERETICGIBBING, 0);
		
	if (a_Level <= 109)
		P_XGSSetValue(a_Master, PGS_GAMEAIRFRICTION, 0);
		
	// MAXPLAYERS Simulation
	if (a_Level <= 109)
		P_XGSSetValue(a_Master, PGS_COLASTLOOKMAXPLAYERS, 4);
	else if (a_Level < 113)
		P_XGSSetValue(a_Master, PGS_COLASTLOOKMAXPLAYERS, 8);
	else
		P_XGSSetValue(a_Master, PGS_COLASTLOOKMAXPLAYERS, 32);
	
	// Legacys from 1.xx to 1.42 break the chainsaw facing somewhat
#if 0
	if (a_Level >= && a_Level <= 142)
		P_XGSSetValue(a_Master, PGS_CONOSAWFACING, 1);
	else	// Otherwise it works fine
		P_XGSSetValue(a_Master, PGS_CONOSAWFACING, 0);
#endif
	
	return true;
}

/* PS_XGSCapValue() -- Caps the input value */
static int32_t PS_XGSCapValue(const P_XGSBitID_t a_Bit, const int32_t a_Value, bool_t* const a_IsValid)
{
	int32_t MinVal, MaxVal, i, pv;
	bool_t Possibly;
	P_XGSVariable_t* Var;
	
	/* Get variable first */
	Var = P_XGSVarForBit(a_Bit);
	
	// Nothing?
	if (!Var)
		return 0;
	
	/* Perform value limiting on it (enum) */
	Possibly = false;
	if (Var->Possible)
	{
		pv = 0;
		
		// Check values and obtain min/max too
		for (i = 0; Var->Possible[i].StrAlias; i++)
		{
			// Min?
			if (strcasecmp("MINVAL", Var->Possible[i].StrAlias) == 0)
				MinVal = Var->Possible[i].IntVal;
			
			// Max?
			else if (strcasecmp("MAXVAL", Var->Possible[i].StrAlias) == 0)
				MaxVal = Var->Possible[i].IntVal;
			
			// Exact Match?
			else if (Var->Possible[i].IntVal == a_Value)
			{
				Possibly = true;
				pv = Var->Possible[i].IntVal;
			}
		}
		
		// Found value? Use pv
		if (Possibly)
		{
			if (a_IsValid)
				*a_IsValid = true;
			return pv;
		}
		
		// Otherwise, cap between min/max
		else
		{
			if (a_IsValid)
				*a_IsValid = true;
			
			if (a_Value < MinVal)
				return MinVal;
			else if (a_Value > MaxVal)
				return MaxVal;
			else
				return a_Value;
		}
	}
	
	/* Set value */
	// There is no possible value for this variable
	if (a_IsValid)
		*a_IsValid = true;
	return a_Value;
}

/* P_XGSSetValue() -- Sets value of variable */
int32_t P_XGSSetValue(const bool_t a_Master, const P_XGSBitID_t a_Bit, const int32_t a_Value)
{
	P_XGSVariable_t* Var;
	bool_t Valid;
	int32_t Value;
	
	/* Get variable first */
	Var = P_XGSVarForBit(a_Bit);
	
	// Nothing?
	if (!Var)
		return 0;
	
	/* Permitted to change value? */
	if (!a_Master)
	{
		// Change it in a tic command
		D_XNetChangeVar(a_Bit, a_Value);
		
		// Return the previous value
		if (Var->WasSet)
			return Var->ActualVal;
		return Var->DefaultVal;
	}
	
	/* Cap the value */
	Valid = false;
	Value = PS_XGSCapValue(a_Bit, a_Value, &Valid);
	
	// Not valid?
	if (!Valid)
	{
		if (Var->WasSet)
			return Var->ActualVal;
		return Var->DefaultVal;
	}
	
	// Set it now
	Var->WasSet = true;
	Var->ActualVal = Value;
	
	/* Set string */
	PS_EXGSValToStr(Var);
	
	/* Call value change function */
	if (Var->ChangeFunc)
		Var->ChangeFunc(Var);
	
	/* Return the value */
	return Var->ActualVal;
}

/* PS_XGSCapValueStr() -- Caps the input value by string */
static int32_t PS_XGSCapValueStr(const P_XGSBitID_t a_Bit, const char* const a_Value, bool_t* const a_IsValid)
{
	int32_t SetVal, i;
	P_XGSVariable_t* Var;
	bool_t Possibly;
	
	/* Check */
	if (!a_Value)
		return 0;
	
	/* Get variable first */
	Var = P_XGSVarForBit(a_Bit);
	
	// Nothing?
	if (!Var)
		return 0;
	
	/* See if string matches possible value */
	Possibly = false;
	if (Var->Possible)
		for (i = 0; Var->Possible[i].StrAlias; i++)
			if (strcasecmp(a_Value, Var->Possible[i].StrAlias) == 0)
			{
				if (a_IsValid)
					*a_IsValid = true;
				return Var->Possible[i].IntVal;
			}
	
	/* See which value to use here */
	if (a_IsValid)
		*a_IsValid = true;
	if (Var->Type == PEXGST_FLOAT)
		return FLOAT_TO_FIXED(strtod(a_Value, NULL));
	else
		return C_strtoi32(a_Value, NULL, 0);
}

/* P_XGSSetValueStr() -- Sets value by string */
int32_t P_XGSSetValueStr(const bool_t a_Master, const P_XGSBitID_t a_Bit, const char* const a_Value)
{
	P_XGSVariable_t* Var;
	int32_t SetVal;
	bool_t Valid;
	
	/* Check */
	if (!a_Value || a_Master)
		return 0;
	
	/* Get variable first */
	Var = P_XGSVarForBit(a_Bit);
	
	// Nothing?
	if (!Var)
		return 0;
	
	/* Cap the value */
	Valid = false;
	SetVal = PS_XGSCapValueStr(a_Bit, a_Value, &Valid);
	
	// Not valid?
	if (!Valid)
		return false;
	
	/* Return the value */
	return P_XGSSetValue(a_Master, a_Bit, SetVal);
}

/***********************
*** NEW GAME OPTIONS ***
***********************/

/*** LOCALS ***/

static bool_t l_NGAutoStart = false;			// Auto start game

static char l_NGNewMap[WLMAXENTRYNAME];			// Map to change to

/* c_NGValues -- New values for everything */
static struct
{
	bool_t IsSet;								// Value is set
	int32_t Value;								// Value changed to
} l_NGValues[PEXGSNUMBITIDS];

/*** FUNCTIONS ***/

/* NG_ResetVars() -- Resets variables */
void NG_ResetVars(void)
{
	int32_t i;
	
	/* Clear auto start */
	l_NGAutoStart = false;
	
	/* Clear map to switch to */
	memset(l_NGNewMap, 0, sizeof(l_NGNewMap));
	
	/* Clear all set values */
	for (i = 0; i < PEXGSNUMBITIDS; i++)
		NG_SetVarDefault(i);
	memset(l_NGValues, 0, sizeof(l_NGValues));
}

/* NG_FromCLine() -- Set vars from command line */
void NG_FromCLine(void)
{
	int32_t a, b, i;
	char* p;
	
	/* Force automatic start? */
	if (M_CheckParm("-autostart"))
		l_NGAutoStart = true;
	
	/* Change map? */
	// First map of episode (assumed 1)
	if (M_CheckParm("-episode"))
	{
		if (M_IsNextParm())
			a = C_strtou32(M_GetNextParm(), NULL, 10);
		else
			a = 1;
		
		// Build Map
		D_BuildMapName(l_NGNewMap, WLMAXENTRYNAME, a, 1);
		l_NGAutoStart = true;
	}
	
	// Warp to map
	if (M_CheckParm("-warp"))
	{
		// Two arguments
		if (g_IWADFlags & CIF_DOUBLEWARP)
		{
			// Episode
			if (M_IsNextParm())
				a = C_strtou32(M_GetNextParm(), NULL, 10);
			else
				a = 1;
			
			// Map
			if (M_IsNextParm())
				b = C_strtou32(M_GetNextParm(), NULL, 10);
			else
				b = 1;
		}
		
		// Just one
		else
		{
			// Episode always 1
			a = 1;
			
			// Only Map
			if (M_IsNextParm())
				b = C_strtou32(M_GetNextParm(), NULL, 10);
			else
				b = 1;
		}
		
		// Build Map
		D_BuildMapName(l_NGNewMap, WLMAXENTRYNAME, a, b);
		l_NGAutoStart = true;
	}
	
	/* Options */
	// Deathmatch
	if (M_CheckParm("-deathmatch"))
		if (NG_SetRules(false, "dm"))
			l_NGAutoStart = true;
	
	// Alt Deathmatch
	if (M_CheckParm("-altdeath"))
		if (NG_SetRules(false, "dm2"))
			l_NGAutoStart = true;
	
	// Rules
	if (M_CheckParm("-rules"))
		if (M_IsNextParm())
		{
			p = M_GetNextParm();
			
			if (NG_SetRules(false, p))
				l_NGAutoStart = true;
		}
	
	// Skill
	if (M_CheckParm("-skill"))
		if (M_IsNextParm())
		{
			p = M_GetNextParm();
			a = C_strtoi32(p, NULL, 10);
			b = 0;
			
			// Numerical
			if (a >= 1 && a <= 5)
				b = a;
			
			// By name alias
			else
				for (i = 0; c_PEXGSPVSkill[i].StrAlias; i++)
					if (!strcasecmp(p, c_PEXGSPVSkill[i].StrAlias))
					{
						b = c_PEXGSPVSkill[i].IntVal + 1;
						break;
					}
			
			// Set skill now?
			if (b > 0)
			{
				NG_SetVarValue(PGS_GAMESKILL, b - 1);
				l_NGAutoStart = true;
				
				// Double Ammo?
				if (b == 1 || b == 5)
					NG_SetVarValue(PGS_PLDOUBLEAMMO, 1);
				
				// Nightmare?
				if (b == 5)
				{
					NG_SetVarValue(PGS_MONFASTMONSTERS, 1);
					NG_SetVarValue(PGS_MONRESPAWNMONSTERS, 1);
				}
			}
		}
	
	// Monster Respawn
	if (M_CheckParm("-respawn"))
	{
		NG_SetVarValue(PGS_MONRESPAWNMONSTERS, 1);
		l_NGAutoStart = true;
	}
	
	// Fast Monsters
	if (M_CheckParm("-fast"))
	{
		NG_SetVarValue(PGS_MONFASTMONSTERS, 1);
		l_NGAutoStart = true;
	}
	
	// No Monsters
	if (M_CheckParm("-nomonsters"))
	{
		NG_SetVarValue(PGS_MONSPAWNMONSTERS, 0);
		l_NGAutoStart = true;
	}
	
	// Predicting Monsters (Legacy)
	if (M_CheckParm("-predicting"))
	{
		NG_SetVarValue(PGS_MONPREDICTMISSILES, 1);
		l_NGAutoStart = true;
	}
	
	// Timer
	if (M_CheckParm("-timer"))
		if (M_IsNextParm())
		{
			a = C_strtoi32(M_GetNextParm(), NULL, 10);
			NG_SetVarValue(PGS_GAMETIMELIMIT, a);
			l_NGAutoStart = true;
		}
	
	// Austin Virtual Gaming
	if (M_CheckParm("-avg"))
	{
		NG_SetVarValue(PGS_GAMETIMELIMIT, 20);
		l_NGAutoStart = true;
	}
	
	// Teamplay (colors)
	if (M_CheckParm("-teamplay"))
	{
		NG_SetVarValue(PGS_GAMETEAMPLAY, 1);
		l_NGAutoStart = true;
	}
	
	// Teamplay (skins)
	if (M_CheckParm("-teamskin"))
	{
		NG_SetVarValue(PGS_GAMETEAMPLAY, 2);
		l_NGAutoStart = true;
	}
}

/* NG_WarpMap() -- Warp to map */
void NG_WarpMap(void)
{
	/* Switch to new map? */
	if (l_NGNewMap[0])
		D_XNetChangeMap(l_NGNewMap, true);
}

/* NG_ApplyVars() -- Applies set variables */
void NG_ApplyVars(void)
{
	int32_t i;
	
	/* Set any variables first */
	// But only for explicitly set ones
	for (i = 0; i < PEXGSNUMBITIDS; i++)
		if (l_NGValues[i].IsSet)
			P_XGSSetValue(true, i, l_NGValues[i].Value);
}

/* NG_SetAutoStart() -- Set game to auto start */
void NG_SetAutoStart(const bool_t a_Value)
{
	l_NGAutoStart = a_Value;
}

/* NG_IsAutoStart() -- Is the game auto starting? */
bool_t NG_IsAutoStart(void)
{
	return l_NGAutoStart;
}

/* NG_SetRules() -- Set next game from rules */
bool_t NG_SetRules(const bool_t a_Master, const char* const a_Name)
{
	const WL_WADEntry_t* Rules;
	WL_ES_t* Stream;
	TINI_Section_t* CurSect;
	TINI_ConfigLine_t* ConfLine;
	char* Opt, *Val;
	P_XGSBitID_t Bit;
	
	/* Find rules entry */
	Rules = WL_FindEntry(NULL, 0, "RMD_RULE");
	
	// No rules?
	if (!Rules)
		return false;
	
	/* Read stream data */
	Stream = WL_StreamOpen(Rules);
	
	// Failed?
	if (!Stream)
		return false;
	
	/* Read INI Sections */
	// Check for unicode
	WL_StreamCheckUnicode(Stream);
	
	// Read all sections for the right one
	CurSect = NULL;
	while ((CurSect = TINI_FindNextSection(CurSect, Stream)))
	{
		// Section name matches?
		if (!strcasecmp(CurSect->Name, a_Name))
			continue;
		
		// Begin reading lines
		ConfLine = TINI_BeginRead(CurSect);
		
		// Read all lines and process their values as such
		while (TINI_ReadLine(ConfLine, &Opt, &Val))
		{
			// Get option for string
			Bit = P_XGSBitForName(Opt);
			
			// As long as it is legal
			if (Bit > PGS_NOTHINGHERE && Bit < PEXGSNUMBITIDS)
				if (a_Master)
					P_XGSSetValueStr(true, Bit, Val);
				else
					NG_SetVarValueStr(Bit, Val);
		}
		
		// End reading lines
		TINI_EndRead(ConfLine);
	}
	
	// Clear sections
	TINI_ClearSections(CurSect);
	
	/* Close Stream */
	WL_StreamClose(Stream);
	return true;
}

/* NG_SetVarValueStr() -- Sets value as string */
int32_t NG_SetVarValueStr(const P_XGSBitID_t a_Bit, const char* const a_NewVal)
{
	/* Check */
	if (a_Bit < 0 || a_Bit >= PEXGSNUMBITIDS || !a_NewVal)
		return 0;
	
	/* Use standard capping */
	return NG_SetVarValue(a_Bit, PS_XGSCapValueStr(a_Bit, a_NewVal, &l_NGValues[a_Bit].IsSet));
}

/* NG_SetVarValue() -- Set variable to value */
int32_t NG_SetVarValue(const P_XGSBitID_t a_Bit, const int32_t a_NewVal)
{
	/* Check */
	if (a_Bit < 0 || a_Bit >= PEXGSNUMBITIDS)
		return 0;
	
	/* Cap and return value */
	l_NGValues[a_Bit].Value = PS_XGSCapValue(a_Bit, a_NewVal, &l_NGValues[a_Bit].IsSet);
	return l_NGValues[a_Bit].Value;
}

/* NG_SetVarDefault() -- Set variable to default */
int32_t NG_SetVarDefault(const P_XGSBitID_t a_Bit)
{
	/* Check */
	if (a_Bit < 0 || a_Bit >= PEXGSNUMBITIDS)
		return 0;
	
	/* Clear set */
	l_NGValues[a_Bit].IsSet = false;
	
	/* Return actual default */
	l_NGValues[a_Bit].Value = l_GSVars[a_Bit].DefaultVal;
	return l_NGValues[a_Bit].Value;
}

/* NG_GetNextValue() -- Get next value (for menus) */
int32_t NG_GetNextValue(const P_XGSBitID_t a_Bit, const bool_t a_Right)
{
	return P_XGSGetNextValue(a_Bit, a_Right);
}

/* NG_SetNextMap() -- Sets the next map */
void NG_SetNextMap(const char* const a_Map)
{
	/* No map? */
	if (!a_Map)
	{
		l_NGNewMap[0] = 0;
	}
	
	/* Placed map */
	else
	{
		strncpy(l_NGNewMap, a_Map, WLMAXENTRYNAME - 1);
		l_NGNewMap[WLMAXENTRYNAME - 1] = 0;
	}
}

